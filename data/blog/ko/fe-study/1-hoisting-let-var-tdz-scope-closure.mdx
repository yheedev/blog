---
title: '호이스팅, let과 var 차이점, TDZ, 스코프, 클로저'
date: '2023. 7. 26.'
tags: ['Javascript']
topics: ['FE Study']
draft: false
summary: '자바스크립트의 호이스팅, let과 var 키워드의 차이점, TDZ(Temporal Dead Zone), 스코프, 클로저에 대한 개념 정리'
toc: true
---

최초 작성: 2023. 7. 26. [notion blog](https://www.notion.so/yheedev/let-var-TDZ-a9b46f399e1b4e7b805eb9d2251e7e22)

<hr className="invisible mt-1" />

2023년 8월 8일 월요일 부터 11월 28일 금요일까지 매주 월, 금 23시 마다 디스코드에서 음성을 통해 프론트엔드 기술면접 질문 모음 레포의 질문들을 5개씩 토의하는 스터디를 진행했다.

[https://github.com/junh0328/prepare_frontend_interview](https://github.com/junh0328/prepare_frontend_interview)

그리고 위 질문들을 아래 링크의 스터디 노션 페이지에 정리해두었고 다음 스터디에 준비할 질문을 공지하는 용도로 사용했다. 또한 일정의 문제나 효율성의 측면에서 레포 내 모든 질문을 다 답변할 수 없었기 때문에 스터디원들과 상의해서 중요성이 떨어진다고 판단되는 질문들은 과감하게 쳐냈다.

[https://perpetual-flavor-3f0.notion.site/FE-bd3a2d447b1846a38603a83ccda1861e](https://www.notion.so/bd3a2d447b1846a38603a83ccda1861e?pvs=21)

나는 자바스크립트나 퍼블리싱 관련 개념을 다루는 서적, 강의를 공부할 때에는 그 지식들이 다소 막연하게 느껴지고 당장 도움을 얻기 어려웠기 때문에 동기 부여 측면에서도 부족했다.

하지만 이 스터디를 통해 기술 면접에서 출제 빈도가 높은 것, 즉 현업에서 자주 언급되거나 사용된다고 일컫어지는 개념들을 공부하면서 실제로 코딩이나 공부를 하면서 점차 이해가는 개념이 생기는 등 많은 도움을 얻었다.

이 기술 면접 스터디를 진행하기 위해서 온라인으로 스터디원들을 모집했다. 그리고 스터디 전까지 각 날짜에 토의할 5개 면접 질문의 답변을 준비해오고 돌아가며 음성으로 발표를 하는 방식으로 스터디를 진행했다.

면접 질문에서 답을 하기 위해 어떤 개념을 보완해서 공부하면 좋은지, 준비한 답변에서 오개념이 있다면 무엇인지 토의를 해서 서로 주고 받은 피드백을 통해 최종적으로 답변을 보완해서 수정했다. 취준생, 신입 부터 2년차의 프론트엔드 개발자 분까지 참여했는데 처음부터 끝까지 쭉 참여해준 스터디원 분들께 감사드리고 싶다.

---

<hr className="invisible mt-1" />

선언: `var a;` 할당: `a = 10;` 선언과 할당: `var a = 10;`

# 1. 호이스팅이 뭔가요?

`var` 키워드는 먼저 변수를 선언하고 이후에 값을 할당하는게 가능하고 에러가 발생하지 않습니다. **변수 선언**이 호이스팅 되어서 스코프 내에 가장 선두로 끌어올려진 것처럼 동작하기 때문입니다. 하지만 실제로 선언, 초기화, 할당은 모두 본래 위치에서 이뤄집니다.

```js
console.log(a) // undefined
var a = 10
console.log(a) // 10
```

호이스팅은 실제로 코드가 끌어올려진게 아니고, 자바스크립트 엔진이 내부적으로 변수 선언을 끌어 올려서 처리하는 것입니다. 그래서 변수를 미리 선언된 상태로 만드는 것이고 실제 메모리 상의 위치의 변경은 없습니다.

`let` 과 `const` 키워드 또한 호이스팅이 되지만, 초기화가 되기 전까지는 TDZ에 놓여서 초기화가 이루어지기 전에는 접근하면 `ReferenceError`가 발생합니다. 이 때문에 호이스팅이 발생하지 않는 것처럼 보입니다.

<hr className="invisible mt-1" />

## ✨ 피드백

- 수정 전에 나는 _'예를 들어 var a라는 변수가 선언되었을 때...'_ 라고 예시를 들며 호이스팅 현상을 설명했다. 스터디원 분은 시각적으로만 설명을 들었을 때에 예시 코드를 들으면 잘 와닿지 않는다는 피드백을 줌.
- 수정 전에 `var` 키워드에 대한 언급만 하며 끝냈는데 스터디원이 변수를 선언했을 때나 `let`, `const` 키워드의 개념을 추가하는 것도 좋을 것 같다는 피드백을 받아서 추가했다.

<hr className="invisible mt-1" />

# 2. let과 var 키워드는 어떤 점이 다른가요?

`var` 키워드

- 재선언과 재할당이 가능한 키워드입니다.
  - 이 때문에 상황에 따라 유연하게 사용할 수 있으나 코드량이 많아지면 사용하기 복잡해진다는 특징이 있습니다.
- 함수 레벨 스코프를 지원합니다.
- 호이스팅 현상을 염두에 두고 사용해야 합니다.
- `var` 키워드를 이용해서 선언한 전역 변수는 전역 객체의 속성이 됩니다. 브라우저 환경에서는 `window` 객체의 속성이 되고, Node.js 환경에서는 `global` 객체의 속성이 됩니다.

```jsx
var a = 10 // 전역 변수 환경
console.log(window.a) // 10
```

<hr className="invisible mt-1" />

`let` 키워드

- ES6에서 추가된 키워드로 **재선언은 불가능하지만 재할당이 가능**합니다. 이를 통해 의도치 않은 변수의 재선언을 방지할 수 있습니다.
- `let`, `const` 키워드는 블록 레벨 스코프를 지원합니다.
- `let` 키워드를 이용해 선언된 변수는 선언과 초기화가 따로 이루어지기 때문에 호이스팅이 발생하지 않는 것처럼 동작합니다.
- `let` 키워드는 `const` 키워드와 마찬가지로 전역 변수를 선언할 때 해당 전역 변수가 전역 객체의 속성이 되지 않습니다.
  전역 범위에서 `let`, `const` 키워드를 사용해서 전역 변수를 선언해도 `window` 객체나 `global` 객체에 새로운 속성을 추가하지 않습니다.
  이를 통해 전역 객체의 오염을 방지할 수 있습니다.
- `let` 키워드는 자바스크립트 파서가 구문을 평가해야만 변수를 값으로 초기화한다는 특징을 갖고 있습니다. 값을 할당하기 전에는 변수를 사용할 수 없도록 스코프의 시작 지점부터 초기화 시작 지점까지 `TDZ`가 형성되기 때문입니다.

```jsx
let b = 20 // 전역 변수 환경
const c = 30 // 전역 변수 환경

console.log(window.b) // undefined
console.log(window.c) // undefined
```

참고

[https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/let](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/let)

<hr className="invisible mt-1" />

## ✨ 피드백

- 수정 전에는 `var` 키워드와 `let` 키워드의 설명에 가까웠다. 스터디원이 설명하는 것을 넘어서 `var` 키워드가 가진 문제점과 한계를 `let` 키워드가 어떻게 해결할 수 있는지에 대한 내용을 보완한다면 더 좋을 것 같다는 피드백을 보내줘서 답변을 좀 더 수정했다.
- `let` 키워드와 `var` 키워드의 차이점 중 추가로 'let으로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다' 라는 것을 배웠다. 자세한 내용은 MDN에서 공부해서 내용을 보완했다.

<hr className="invisible mt-1" />

# 3. TDZ

변수는 일반적으로 선언 → 초기화 → 할당 단계를 거치면서 생성됩니다. `TDZ`(Temporal Dead Zone, 일시적 사각지대)는 변수의 선언 → 초기화 단계 사이에서 일시적으로 변수를 참조할 수 없는 (에러가 발생하는) 구간을 뜻합니다. 이를 통해 변수의 선언과 초기화 순서를 좀 더 명확하게 만들 수 있습니다.

- `var` 키워드로 선언된 변수는 선언과 함께 `undefined`로 초기화 됩니다. 선언과 초기화 단계가 동시에 실행되기 때문에 `TDZ`가 존재하지 않습니다.
- `let` 키워드로 선언된 변수는 선언, 초기화, 할당 단계 사이가 분리되어 있습니다. **선언 단계와 초기화 단계 사이에 TDZ가 존재합니다.**
- `const` 키워드로 선언된 변수는 선언과 초기화 단계가 동시에 실행됩니다. **선언 단계와 초기화 단계 사이에 TDZ가 존재합니다.**
  따라서 `let` 키워드와 `const` 키워드의 변수를 선언만 하고 접근을 할 경우 레퍼런스 에러가 발생합니다.

```jsx
console.log(c) // ReferenceError: c is not defined
const c = 30
console.log(c) // 30
```

<hr className="invisible mt-1" />
## ✨ 피드백

- 어디서 TDZ 현상을 만날 수 있는지 예시를 추가로 넣으면 좋을 것 같다는 피드백을 받아서 수정해보았다.
  <hr className="invisible mt-1" />

# 4. 스코프가 뭔가요?

스코프는 식별자가 선언된 위치에 따라 유효할 수 있는 범위를 결정합니다. 스코프는 **전역 스코프**와 **지역 스코프** 두 개로 나뉠 수 있습니다.

- `전역 스코프 (Global scope)`
  - 최상위의 위치에 있기 때문에 전역 스코프에 선언된 변수는 코드 어디에서나 접근할 수 있습니다.

- `지역 스코프 (Local scope)`
  - 특정 블록에서만 접근 가능한 범위를 갖고 있습니다.
  - 지역 스코프는 중첩이 가능하며 클로저 같은 `스코프 체인`을 형성할 수 있습니다. - 스코프 체인은 여러 개의 중첩된 스코프가 연결된 구조를 의미합니다. - 하위 스코프에서 변수를 찾을 때, 해당 스코프에 변수가 없으면 상위 스코프를 따라, 최종적으로 전역 스코프까지 올라가며 변수를 찾습니다. - 하위 → 상위 스코프의 변수 접근은 가능합니다. 하지만 상위 → 하위 스코프의 변수 접근은 불가능합니다.
    <hr className="invisible mt-1" />

## ✨ 피드백

- 스코프 중첩을 통한 스코프 체인 개념을 언급하는 것이 좋겠다는 피드백을 받음.
- 스터디 준비를 하면서 var, let, const, 함수의 유효한 스코프 범위까지 작성하다가 불필요하다고 느껴져서 최대한 간략하게 작성했다.
- 스코프가 뭐냐는 질문은 너무 광범위하게 느껴지는데 이런 질문을 받는다면 어떻게 답을 해야할지 고민이 듦..
  <hr className="invisible mt-1" />

# 5. 클로저에 대해 아나요?

1. 함수 내부에 내부 함수가 생성됨.
2. 내부 함수가 외부 함수의 변수를 사용 및 접근하는 상황. (조건 1)
3. 내부 함수는 외부 함수가 종료된 후에도 유지될 수 있어야 함. (조건 2)
4. 외부 함수가 실행을 마치고 소멸됨.
5. 여전히 내부 함수가 외부 함수의 변수에 접근이 가능한 현상: **클로저**

6. **왜 외부 함수의 소멸 이후에 내부 함수 → 외부 함수의 변수 접근이 가능한가?**:

   내부 함수가 외부 함수의 스코프 체인을 유지하기 때문이다.

7. **외부 함수가 소멸되면 외부 함수의 변수도 소멸되어야 하는게 아닌가?**:

   원래는 그래야 함.

   하지만 클로저가 생성된 경우에는 내부 → 외부 변수가 여전히 접근이 가능해져야 함. 그래서 외부 함수의 변수들은 소멸되지 않고 메모리에 유지된다.

8. **스코프 체인도 메모리에 저장되는가?**:

   맞음. 각 함수가 실행될 때 생성되는 실행 컨텍스트에 스코프 체인이 포함된다.
   하지만 클로저가 생성된 경우에는 해당 스코프 체인이 메모리에 유지된다.

클로저는 주로 상태를 유지하고 변경하는 데 사용됩니다. 예를 들어, React의 `useState` 훅은 클로저를 사용하여 상태를 관리합니다. `useState` 함수에서 반환된 `state`를 통해서만 상태에 접근이 가능하고, `setState`를 통해서만 상태값을 업데이트할 수 있도록 합니다.

```jsx
import React, { useState } from 'react'

function Counter() {
  const [count, setCount] = useState(0)

  function increment() {
    setCount(count + 1)
  }

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  )
}
```

위 예제에서 `Counter` 컴포넌트 (외부 함수) 내부의 `increment` 함수는 `setCount`를 통해 `count` 변수에 접근할 수 있는 클로저를 형성합니다.

`Counter` 컴포넌트가 다시 렌더링된 후에도 `increment` 함수는 여전히 `count` 변수에 접근할 수 있으며, 이는 상태 관리의 일관성을 유지하고 예측 가능한 동작을 보장합니다.

<hr className="invisible mt-1" />
## ✨ 스터디원 분들과의 피드백

- 클로저 개념 설명에서 useState로 예시를 들던 스터디원 분의 설명이 너무 멋있었어서 다른 예시를 통해 인용 해보았다.

---

# 1회차 회고

스터디원 분들과 '현실적으로 이걸 외워서 면접장에서 얘기할 수 있을까?'에 대한 이야기를 나눴다. 기술 면접 질문의 모든 답을 완벽하게 외워서 대답하는 것은 불가능할 것이다.

그래도 이렇게 차근차근 공부해온 답변을 공유하면서 우선 기술 공부를 한다는 느낌으로 준비해보기로 했다. 답변하는 과정과 피드백을 바탕으로 수정하는 과정이 쌓여서 언젠가 도움이 될 것 같다.

그리고 내가 꾸준하게 미괄식으로 말하는 사람이라는걸 깨달았다. 음성 스터디의 정말 큰 장점이였다. 앞으로 최대한 두괄식으로 말을 해봐야겠다고 다짐했다.
