---
title: 'types/constants, utils/lib/hooks 경로의 차이점'
date: '2025. 07. 24.'
tags: ['TypeScript', 'React', 'Guide']
topics: ['TIL']
draft: false
summary: ''
toc: true
---

최초 작성: 2025. 07. 24. [notion blog](https://www.notion.so/yheedev/types-constants-utils-lib-hooks-23ac7639cb49802492b3cc0aee776be8)

새 프로젝트를 마이그레이션하면서 기존 함수에 선언했던 타입, 상수들과 공통적으로 사용하는 함수 등을 분리하면서 새로운 폴더를 여러 개 만들었다

비슷하게 느껴지는 이 폴더들의 차이점이 무엇인지 정리해보았다

<hr className="invisible mt-1" />

# types

타입 정의(Shape of Data)를 위한 코드들이 주로 들어가며, TypeScript에서 사용하는 타입(alias, type, interface 등)을 정의하는 폴더이다. 객체 구조, API 응답 타입, Props, Zustand/Redux State 타입 등 정적 타입 검사를 위한 용도로만 사용된다.

```tsx
export type TypeNameElement = (typeof TypeName)[number]

interface Props {
  className?: string
  text?: string
  borderColor: string
  onClick?: (isActive: boolean) => void
  isActive?: boolean
  isDarkMode: boolean
  upToTwo?: (type: string) => void
  cursor?: string
}
```

이 코드들은 컴파일 시에 제거되고, 번들과 런타임 코드에 포함되지 않는다. 대부분 코드 작성 시에 IDE 자동 완성 (오타 방지), 오류 검사 등을 위해 주로 사용된다.

이렇다 보니 주로 TypeScript가 아닌 JavaScript를 사용한 프로젝트에서는 types 폴더가 대부분 존재하지 않는다.

JavaScript는 정적 타입 시스템이 없기 때문에 타입을 컴파일 시점에 검사하지 않고 런타임에서만 에러를 확인한다. 따라서 interface, type, enum 같은 타입 정의 구문 자체가 존재하지 않고, types 폴더가 의미를 가지지 않는다.

그리고 JavaScript만 사용하는 프로젝트라도 `@types/...` 로 시작하는 일부 외부 라이브러리를 사용하기 위해 설치할 수 있긴 하다.

그래서 JavaScript를 사용하면서 타입을 선언하고 싶을 때에는 JSDoc을 사용하는게 대안으로 제안된다. 이는 IDE 자동 완성과 같이 코드 작성에 도움을 주지만, 타입 오류를 막을 수는 없다.

````mdx
```tsx
// JSDoc 예시
/**
 * @param {number} a
 * @param {number} b
 * @returns {number}
 */
function add(a, b) {
  return a + b
}
```
````

<hr className="invisible mt-1" />

# constants

types 폴더의 예시에 들어가는 값들은 다양한 string, boolean, void 등 고정되지 않은 값을 가질 수 있지만 constants 폴더에 속하는 코드들은 항상 변하지 않는 고정된 값 (상수)들이라는 공통점이 있다.

constants 폴더에 있는 값들은 주로 런타임 중에도 사용되기 때문에, TypeScript 컴파일 시 JavaScript 코드로 변환되어서 번들에 포함된다. 이 값들은 런타임 실행 중에 UI에서 타입 버튼을 렌더링하거나 공격 함수를 계산할 때 사용되는 고정된 값으로 사용되기 때문에 번들에 포함된다.

앱 전체에 재사용되는 문자열이나 숫자, 앱 실행 중 실제로 사용되는 값 등을 constants 폴더 내에 작성해서 반복적으로 사용되는 하드코딩 문자열 피할 수 있다. 이 값들은 여러 곳에서 사용되기 때문에 상수로 작성해두면 유지보수가 편하다는 장점이 있다.

```tsx
export const PATH = {
  offense: '/:lang',
  defense: '/:lang/defense',
  more: '/:lang/more',
}

export const TypeName = [ 'normal', 'fighting', 'flying' ....] as const
export const TypeValue = {
   normal: [1, 1, 1, 1, 1, 0.5, 1, 0, 0.5, 1, 1, 1, 1, 1, 1, 1, 1, 1],
  fighting: [2, 1, 0.5, 0.5, 1, 2, 0.5, 0, 2, 1, 1, 1, 1, 0.5, 2, 1, 2, 0.5],
  // ...
}

export const langs = { ko, en, ja };

export const LANGS = ['ko', 'en', 'ja'] as const
export type Language = typeof LANGS[number]
```

포켓몬 타입들도 상수로, 런타임 중에 사용되는 값들이라는 공통점이 있다.

as const는 타입스크립트가 값에서 리터럴 타입을 추론하게 돕는 도구이다. type이나 interface 같은 타입은 아니지만 정적인 상수에 타입 안정성을 부여하기 위한 수단이다.

<hr className="invisible mt-1" />

## `types` vs `constants`

| 항목                 | `types`                                 | `constants`                            |
| -------------------- | --------------------------------------- | -------------------------------------- |
| **역할**             | 타입 정의 (`interface`, `type`)         | 런타임 상수 정의 (`const`, `as const`) |
| **언어 대상**        | TypeScript 전용                         | JS/TS 공통                             |
| **런타임 포함 여부** | ❌ 포함 안 됨 (컴파일 시 제거)          | ✅ 포함됨 (JS 코드로 변환됨)           |
| **사용 목적**        | 코드 작성 시 IDE 자동완성, 타입 안정성  | 앱 실행 중 사용되는 값 관리            |
| **의존성**           | 없음                                    | 거의 없음 (경량 상수 위주)             |
| **예시**             | `User`, `ComponentProps`, `ApiResponse` | `PATH`, `TypeName`, `LANGS`            |
| **어디서 사용됨**    | 컴포넌트, API, 상태 정의 등             | 조건 분기, UI 렌더링, 라우팅, 계산 등  |
| **유도 관계**        | `typeof CONSTANT[number]`로 유도 가능   | 타입 유도에 활용됨                     |

<hr className="invisible mt-1" />

# utils

순수 함수 중심의 유틸 함수를 주로 모아둔다. 특정 라이브러리나 프레임워크에 의존하지 않고, 주로 입력값과 출력값이 일관적인 형태로 동작한다.

재사용성, 테스트 용이성, 사이드 이펙트 없음이 핵심이다.

```tsx
// utils/allTypes1x.ts

import { TypeValue } from '@/constants/pokemon'

export function getEffectArray(type?: string): readonly number[] {
  return type && type in TypeValue
    ? TypeValue[type as keyof typeof TypeValue]
    : new Array(18).fill(1)
}
```

<hr className="invisible mt-1" />

# lib

외부 라이브러리, API 통신 등과 연관된 유틸/모듈을 모아둔다. 보통 외부 의존성이 있는 비즈니스 로직/연동 로직에 사용한다.

주로 라이브러리들끼리 모아서 함수를 만들어두는 코드나 i18n.ts, axios.ts 등이 포함된다.

```tsx
// lib/axios.ts
import axios from 'axios'

const instance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  withCredentials: true,
})

export default instance
```

```tsx
// lib/utils.ts

import { clsx, type ClassValue } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(...input))
}
```

<hr className="invisible mt-1" />

# hooks

리액트 전용 커스텀 훅을 `use...` 형태로 모아둔 폴더이다. 상태 관리, 사이드 이펙트, 뷰 관련 로직을 분리해서 재사용성을 높일 수 있다.

주로 다크모드, 스크롤, useMutation 등을 작성해서 커스텀 훅을 분리하고 상태나 이벤트를 관리할 수 있다.

다소 리액트에 의존한다는 점이 특징적이다.

```tsx
// hooks/useScrollPosition.ts
import { useEffect, useState } from 'react'

export function useScrollPosition(): number {
  const [position, setPosition] = useState(0)

  useEffect(() => {
    const onScroll = () => setPosition(window.scrollY)
    window.addEventListener('scroll', onScroll)
    return () => window.removeEventListener('scroll', onScroll)
  }, [])

  return position
}
```

<hr className="invisible mt-1" />

## `utils`, `lib`, `hooks`, `types`, `constants` 비교

| 항목                    | `utils`                      | `lib`                    | `hooks`                     | `types`                        | `constants`                  |
| ----------------------- | ---------------------------- | ------------------------ | --------------------------- | ------------------------------ | ---------------------------- |
| **주요 역할**           | 순수 계산, 포맷, 검증        | 외부 연동, SDK 초기화    | React 커스텀 훅             | 타입 정의                      | 불변 상수 정의               |
| **React 의존성**        | ❌ 없음                      | ❌ 없음                  | ✅ 있음                     | ❌ 없음                        | ❌ 없음                      |
| **외부 의존성**         | ❌ 없음                      | ✅ 있음 (axios, i18n 등) | 🔼 (종종 React 외 lib 포함) | ❌ 없음                        | 보통 없음, 가볍게만 사용     |
| **컴파일 후 코드 포함** | ✅ 포함됨                    | ✅ 포함됨                | ✅ 포함됨                   | ❌ 제거됨                      | ✅ 포함됨                    |
| **테스트 용이성**       | ✅ 매우 높음                 | 🔼 중간                  | 🔼 중간~높음                | ❌ 필요 없음                   | ✅ 높음                      |
| **예시**                | `formatDate`, `isValidEmail` | `axios.ts`, `i18n.ts`    | `useScroll`, `useDarkMode`  | `User`, `Props`, `ApiResponse` | `PATH`, `LANGS`, `TypeValue` |

<hr className="invisible mt-1" />

## 보너스: 폴더 이름을 복수로 지어도 괜찮나 ex: components

components, types, constants, stores ... 등으로 복수형으로 짓는게 괜찮은가 싶었다.

근데 해당 폴더에 여러 개의 타입(types), 여러 개의 컴포넌트(components)가 모여있다보니 복수형 사용이 권장된다고 한다. 단수는 특정 기능의 단일 책임이 필요할 때 사용한다고 함.
