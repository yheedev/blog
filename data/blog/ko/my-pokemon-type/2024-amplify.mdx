---
title: 'Amplify, Route 53 세팅: CI/CD 자동화 및 배포, 도메인 구입'
date: '2024-07-29'
tags: ['AWS', 'Amplify', 'Route 53']
projects: ['My Pokemon Type']
draft: false
summary: '마이그레이션 이전 My Pokemon Type 배포 과정'
toc: true
---

최초 작성: 2025. 7. 29. [notion blog](https://www.notion.so/yheedev/Amplify-Route-53-CI-CD-Cloudfront-64a96d7866f94484817f933f8e42a081#6055febcd6d9400b888085f47a372111)

2025년 기준 만료된 `mypkmn.info` 도메인을 등록했던 과정입니다. 현재는 `mypokemontype.vercel.app` 으로 이전했습니다.

<hr className="invisible my-3" />

# Amplify, Route 53: 배포와 CI/CD 자동화, 도메인 구입, Cloudfront 시도..

맨 처음으로 aws 서비스 사용해보는건데 거의 타입스크립트랑 리액트 처음 접하기 전 만큼이나 겁을 엄청나게 많이… 먹었었기 때문이다

그치만 막상 해보니 생각만큼 그리 어렵지도 않았었고,, 또 헤맬 수 있으니 나중을 위해서 자세히 기록해둔다

# 1. 도메인 구입 (가비아, route53)

내가 원하는건 `mypkmn.info`, `mypkmn.xyz` `mypkmn.me` 등 부담없는 도메인이였다.
어차피 aws 서비스들로 배포하니까 aws route53에서 도메인을 구입하자고 해보자고 생각했지만 . .. .

`mypkmn.info` 도메인

- 가비아 도메인 구입비용: 6,000원 x 1년 + 부가세 600원
- aws route53 도메인 구입비용: 25달러 (대충 한화 35,000원) 그외 최소 14달러부터 시작함

그래서 걍 가비아에서 구입하기로 했다

## 1.1. 도메인 결제

![가비아 도메인 결제](/static/images/my-pokemon-type/amplify1.png)

가비아에서 원하는 도메인 선택해서 처음 구입할 땐 위 과정이 제일 막막했는데,, 일단 걍 저렇게 체크하고 넘어가면 된다.

## 2. Route53 콘솔 세팅

[Amazon Route 53 - DNS 서비스 - AWS](https://aws.amazon.com/ko/route53/)

1. aws route53 서비스에 들어가서 호스팅 생성 클릭
2. 내가 구입한 도메인 수기로 입력. 나같은 경우에는 내가 구입한 도메인인 `mypkmn.info`를 입력했다.

그럼 아래와 같이 나온다.

![Route53 호스팅 생성 결과](/static/images/my-pokemon-type/amplify2.png)

레코드가 총 두 개 나오던데 차이점이 무엇인지는 모르겠으나,, 여튼 `ns-`로 시작하는 어떤 네임서버 4개를 주는 저 레코드가 중요한 것이다.

그리고 다시 가비아로 돌아와서, 내 도메인 설정에 들어가서 네임서버 설정에 들어가서 **route53에서 제공해주는 4개의 레코드를 모두 맨 끝의 온점을 제외하고!! 차례대로 입력해준다**

![Route53 네임서버 설정](/static/images/my-pokemon-type/amplify3.png)

도메인 구입 단계 끝

# 2. amplify

1. aws amplify 에 접속해서 시작하기 클릭
2. 난 깃허브를 클릭하고 only select repo -> 여태 프로젝트를 진행해온 레포 클릭함.

   이 2단계를 위해 amplify에 지정한 레포에 액세스 권한 부여해야 함.

단순히 깃헙 계정과 aws 계정의 연결이 아님. 깃헙 레포와 amplify 앱 자체의 연결이 필요하다는 뜻이다

[https://docs.aws.amazon.com/ko_kr/amplify/latest/userguide/setting-up-GitHub-access.html](https://docs.aws.amazon.com/ko_kr/amplify/latest/userguide/setting-up-GitHub-access.html)

대충 요약: amplify가 내 깃헙 레포에 접근해서 알아서 코드 변경사항들을 자동으로 빌드, 테스트, 배포(CI/CD)하기 위해서는 amplify의 읽기 전용 액세스를 승인해야 합니덩

이 단계에서 다음 단계로 쭉쭊쭉

![레포지토리 및 브랜치 추가](/static/images/my-pokemon-type/amplify4.png)

뭐지.. 내 앱은 모노 리포지토리임< 이거 내가 배포하려는 레포지토리 설명을 기억 안나는 언젠가 아무렇게나 음슴체로 썼나 싶어서 쫄아서 수정하려고 애썼었다

![언니랑 카톡](/static/images/my-pokemon-type/amplify5.png)

근데 걍 진짜 AWS의 안내문이 번역되었던거 였다고 한다,,

## 2.1. 배포1 실패: npm ci

![npm ci 배포 실패 로그](/static/images/my-pokemon-type/amplify6.png)
![npm ci 배포 실패 로그2](/static/images/my-pokemon-type/amplify7.png)
![npm ci 배포 실패 로그3](/static/images/my-pokemon-type/amplify8.png)

검색해본 결과 npm ci 가 설치되어있지 않거나 프로젝트 내 특정 의존성 라이브러리나 프레임워크가 최신 버전이 아닐 경우 발생하는 에러라고 나왔다.

그래서 `npm install ci` 를 실행해서 설치했다.

그 다음에 add > commit > push 를 하고 나니까 자동으로 aws amplify 사이트에서 자동으로 배포가 실행되어서 로컬 페이지가 아닌 `pkmn.info`에 변경사항이 반영되었다
첫 배포라서 너무너무 신기한 경험이였다,,

## 2.2. 배포2 실패: node_modules package-lock.json 삭제후 재설치

두 번째 배포에서는 아래와 같은 에러가 발생했다

![detached HEAD 에러 로그](/static/images/my-pokemon-type/amplify9.png)
![detached HEAD 에러 로그2](/static/images/my-pokemon-type/amplify10.png)
![detached HEAD 에러 로그3](/static/images/my-pokemon-type/amplify11.png)

`detached HEAD` 상태라고 나오길래 브랜치 문제인줄 알았다. 내 레포지토리의 브랜치는 1개 뿐인데..? 헷깔렸었다. 검색해본 결과 `detached HEAD` 상태는 브랜치 관련 경고일 뿐, 실제 빌드 실패의 원인은 아니다. `detached HEAD` 상태는 특정 커밋에 체크아웃된 상태를 의미하며, 이는 빌드 과정에서 일반적으로 발생할 수 있다고 한다.

`npm install ci`를 한 번 더 해봤다가.. 에러가 너무 많이 나서 전부 다 지우고 다시 해보기로 함

```
rm -rf node_modules package-lock.json // node_modules, package-lock-json 삭제
npm cache clean --force // npm 캐시 정리
npm install // 재설치
```

![배포 성공 로그](/static/images/my-pokemon-type/amplify12.png)

ㅠㅜ 이야 감동적이다

## 2.3 배포 후 webp 이미지가 안 보임: amplify 콘솔에서 확장자 추가

배포 성공 후에 로컬 환경에서 잘 보였던 `.webp` 이미지가 안 보이고 alt 텍스트가 노출되는 상태였다. `.webp` 이미지와 같은 위치에 있는 `.svg` 파일들은 모두 잘 보이고 있기 때문에 경로 상의 문제는 아닐거라고 추측했다.

[https://docs.aws.amazon.com/ko_kr/amplify/latest/userguide/redirects.html](https://docs.aws.amazon.com/ko_kr/amplify/latest/userguide/redirects.html)

aws amplify 콘솔에서 내 앱 > 호스팅 > 재작성 및 리디렉션 (Rewrites and redirects) > 리디렉션 관리 클릭

![Amplify 다시 쓰기 및 리디렉션 페이지](/static/images/my-pokemon-type/amplify13.png)

맨 아랫줄의 ‘소스 주소’ 부분을 수정하면 된다. 나같은 경우에는 `.webp` 확장자 파일이 안 보이는 상태라서 기존 확장자들과 함께 `.webp` 확장자만 추가한 아래의 형태로 수정해주었다.

```jsx
</^[^.]+$|.(?!(css|gif|ico|jpg|jpeg|webp|js|png|txt|svg|woff|ttf|map|json)$)([^.]+$ )/>
```

이 다음에도 push 해주면 끝!

이 경우 IDE에서 작성한 내용이 없어서 커밋할 때 `nothing to commit, working tree clean` 가 나와도 push도 배포도 잘되었다. 이후 `.webp` 이미지가 잘 나왔다!!

## 2.4. 도메인 연결

배포를 끝낸 다음에만 가비아에서 구입해서 route53의 네임 서버를 복붙해뒀던 그 도메인을 비로소 amplify로 배포한 페이지와 연결할 수가 있었다.

amplify 페이지에서 앱 > 호스팅 > 사용자 지정 도메인 클릭해서 설정을 하면 된다.

도메인의 경우 route53에 등록해놓은 도메인이 있는 경우에는 자동으로 그 전에 내가 수기로 등록한 `mypkmn.info`가 나오면서 걍.. 클릭만 하면 순식간에 도메인 연결 끝임 ㅠ 너무너무 친절한 aws..

그 외에는 route53에서 설정한 네임서버가 올바르게 연결되었는지 확인하면 된다.

# 3. cloudfront

## 3.1. cloudfront 콘솔에서 배포 생성

[https://us-east-1.console.aws.amazon.com/cloudfront/v4/home?region=us-east-2#/welcome](https://us-east-1.console.aws.amazon.com/cloudfront/v4/home?region=us-east-2#/welcome)

1. 위 링크의 cloudfront console 페이지에 접속해서 새로 생성

`origin domain`: 등록하고자 하는 도메인인 [mypkmn.info](http://mypkmn.info/) 을 직접 작성함

그외에 `프로토콜`: HTTPS만 해당 / `HTTPS port`: 443 / `Minimum Origin SSL protocol`: TLSv.12

,,, 이것들은 그냥 이렇게 자동으로 선택되어 있었다.

그리고 `Supported HTTP versions`은 HTTP/2만 체크했다. HTTP/3을 클릭하니까 이후 배포가 진행되지 않았기 때문임,,

![cloudfront 배포 생성 설정](/static/images/my-pokemon-type/amplify14.png)

그럼 배포가 생성됨

## 3.2. cloudfront 기능을 필요로 하는 파일 수정: languageslice, app.tsx

내가 cloudfront 서비스를 사용하는 이유는 내가 만든 앱에 접속하는 유저의 위치에 따라 자동으로 한국어/영어/일본어를 지원하고 싶기 때문이였다.
그래서 cloudfront 서비스를 필요로 하는 프로젝트 내 languageSlice 파일을 수정했다.

```tsx
// src/feature/languageSlice.tsx
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import kr from '../json/kr.json'
import us from '../json/us.json'
import jp from '../json/jp.json'

export const handler = async (event: { Records: { cf: { request: any } }[] }) => {
  const request = event.Records[0].cf.request
  const headers = request.headers

  const country = headers['cloudfront-viewer-country']
    ? headers['cloudfront-viewer-country'][0].value
    : 'KR'

  let lang = 'kr'

  lang = country === 'US' ? 'us' : country === 'JP' ? 'jp' : 'kr'

  headers['set-cookie'] = [{ key: 'Set-Cookie', value: `lang=${lang}; Path=/` }]

  if (typeof window !== 'undefined') {
    localStorage.setItem('lang', lang)
  }

  return request
}

const langs = {
  us: us,
  kr: kr,
  jp: jp,
}

export type langState = {
  lang: 'kr' | 'us' | 'jp'
  translations: typeof kr
}

export const languageSlice = createSlice({
  name: 'language',
  initialState: {
    lang: 'kr',
    translations: kr,
  },
  reducers: {
    language: (state, action: PayloadAction<'kr' | 'us' | 'jp'>) => {
      state.lang = action.payload
      state.translations = langs[action.payload] || kr
      localStorage.setItem('lang', action.payload)
    },
  },
})

export const { language } = languageSlice.actions
export default languageSlice.reducer
```

`handler` 함수에서 Lambda@Edge 함수를 작성하여 사용자의 위치에 따라 언어를 설정하고 이 함수를 CloudFront 배포의 `Viewer Request` 이벤트에 연결했다.

기본 언어는 한국어이고, 유저의 위치가 한국이면 한국어로, 일본이면 일본어로, 그 외 위치일 때에는 영어로 나오도록 했다.

이후에 유저가 언어 선택 모달에서 한, 영, 일 언어 중 하나를 선택하면 해당 언어가 로컬 스토리지에 저장되어서 이 사이트에 계속 적용되도록 했다.

`handler` 함수에서는 다음과 같은 역할을 수행하도록 했다.

1. `event.Records[0].cf.request`를 통해 클라이언트의 요청 정보를 추출 후에 headers 변수에 요청 헤더 저장
2. `headers['cloudfront-viewer-country']`를 통해 클라이언트의 국가 정보를 확인함.
3. 국가 정보에 따라 언어 설정을 결정함. 이 때 국가 정보가 없거나 국가 정보가 `KR`, `US`, `JP` 외에 다른 값일 경우 한국어로 설정됨
4. 클라이언트에게 언어 설정을 전달하기 위해 `Set-Cookie` 헤더 설정. 이 때 쿠키 값은 `lang=${lang}; Path=/` 형식으로 설정됨.
5. 클라이언트 측에서 실행될 경우 (`typeof window !== 'undefined'`), 로컬 스토리지에 언어 설정을 저장한다.
6. 최종적으로 수정된 `request` 객체를 반환함. 이 때 `set-cookie`가 추가된 상태로 반환되는 것임.

### 난 모든 상태를 로컬 스토리지에 저장 중인데 왜 쿠키를 사용해야할까?

헤더 정보나 `cloudfront-viewer-country`와 같은 값은 서버 측에서 **클라이언트**로 전달되는 정보이다. 그리고 서버에서는 로컬 스토리지에 접근할 수 없다. **로컬 스토리지는 클라이언트 측에서만 접근 가능**하며, 서버와의 통신 없이 클라이언트 측에서 상태를 유지하는 데 사용된다.

반면에 쿠키는 클라이언트와 서버 간의 상태를 유지하고, 서버가 클라이언트의 상태를 추적할 수 있도록 도와준다. 따라서 `cloudfront-viewer-country`와 같은 헤더 정보는 서버 측에서 클라이언트로 전달되는 정보이므로, 이를 기반으로 서버에서 쿠키를 설정하는 것이 일반적이다.

요약: 나는 로컬 스토리지는 기존의 다른 상태들 저장하는 데에 그대로 쓰면 된다. 그리고 내가 cloudfront를 이용해서 유저 위치에 따라 언어 변경을 지원하는 기능을 구현하기 위해서는 쿠키도 사용해야함.

참고로 'US', 'KR' 같이 정해져있는 국가 코드에 맞춰서 사용을 해야 view request 이벤트와 잘 연결된다고 한다 ,,, 기존에.. en, ko 같은걸 썼었다가 굉장히 삽질을 했다

```tsx
// src/App.tsx
import { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { setLanguage } from './features/languageSlice';

export function App() {
  const dispatch = useDispatch();
	const lang = useSelector((state: RootState) => state.language.lang);

	  useEffect(() => {
    document.body.setAttribute('data-theme', darkMode);
  }, [darkMode]);

  useEffect(() => {
    dispatch(language(lang as 'kr' | 'us' | 'jp'));
  }, [dispatch, lang]);

  return (... );
}

export default App;
```

추가로 `App.tsx`를 수정해주면 리액트 컴포넌트의 라이프사이클에 맞춰 언어 설정을 쉽게 업데이트할 수 있다. 여기에는 언어 설정 말고 다크모드 관련 useEffect도 있어서 상태 관리하기가 더 나을 것 같았다.

## 3.3 cloudfront 콘솔에서 세팅

![cloudfront 들어가면 배포가 두 개 있는데 유형이 스테이징, 프로덕션으로 나뉘어져있다.](/static/images/my-pokemon-type/amplify15.png)

cloudfront 들어가면 배포가 두 개 있는데 유형이 스테이징, 프로덕션으로 나뉘어져있다.
스테이징은 테스트 환경에 가깝고, 프로덕션은 실제 사용자 환경에 가깝다고 한다. 그러니까 스테이징에서 배포해보고 괜찮으면 프로덕션에 적용해서 안정성을 추구할 수 있는 것 같다.

나는 시간이 없어서 그냥 프로덕션에 배포를 했다.

![cloudfront 배포 세팅](/static/images/my-pokemon-type/amplify16.png)

근데 나중에 이런 실수를 해서 걍 스테이징 배포를 애용하기로 했음,,

![cloudfront 헤더 추가 설정](/static/images/my-pokemon-type/amplify17.png)

우선 프로덕션 배포 ID 클릭해서 동작 (`Behaviors`) 탭을 클릭했다. 그리고 `/기본값(*)` 클릭해서 편집을 한다

![cloudfront 헤더 추가 설정2](/static/images/my-pokemon-type/amplify18.png)

그리고 헤더에 cloudfront-viewer-country 를 추가해줌,, 이외에 뭔가 더 세팅을 해야하지 않았을까..?

지금 (24. 07. 29) 사실 위치기반으로 제대로 작동을 하지 않고 있지 않다 ㅠ 뭔가 추가적인 조치를 해야함
