---
title: '바벨, TSC, 폴리필의 기능, 장단점 '
date: '2024. 07. 16.'
tags: ['TypeScript', 'JavaScript', 'TIL']
draft: false
summary: ''
toc: true
---

최초 작성 2024. 7. 16. [notion blog](https://www.notion.so/yheedev/TSC-fbaa28b2f5fe4b0db335e82a4f0913d0)

<hr className="invisible mt-1" />

# 1. 바벨?

바벨은 ES6+ 버전 이상의 자바스크립트나 `jsx`, `ts`, `tsx` 등 코드를 ES5의 코드로 변환 시켜 IE나 다른 브라우저에서 동작할 수 있도록 하는 역할을 한다. 바벨을 사용해서 **크로스 브라우징** 작업을 할 수 있다는 장점이 있다.

<hr className="invisible mt-1" />

## 1.1 바벨은 ES6 → ES5 뿐 아니라 `.ts` → `.js` 도 가능하다

바벨은 타입스크립트 코드를 자바스크립트로 변환하는 데에도 사용된다. 타입스크립트는 브라우저나 Node.js에서 직접 실행될 수 없기 때문에 자바스크립트로 변환하는 과정이 필요한데, 이 때 바벨을 사용해서 변환할 수 있다.

이를 위해 타입스크립트를 자바스크립트로 변환하는 주요 방법은 타입스크립트 컴파일러(TSC), 바벨(Babel) 이 두 가지 방법이 있다.

<hr className="invisible mt-1" />

## 1.2 TSC와 바벨의 차이점과 장단점

### **TypeScript 컴파일러 (TSC)**

- 타입스크립트 공식 컴파일러로, `.ts` 파일을 `.js` 파일로 변환한다. **이 과정에서 타입 검사를 수행하고, 타입스크립트의 타입 관련 코드를 제거**한다.
- TypeScript 코드를 순수 JavaScript 코드로 변환한다. TypeScript는 JavaScript에 정적 타입을 추가한 언어로, 개발자가 더 안전하게 코드를 작성할 수 있도록 돕는다.

**장점**

- **정적 타입 체크**: 코드의 오류를 컴파일 시점에 발견할 수 있어, 런타임 오류를 줄일 수 있다.
- **객체 지향 프로그래밍 지원**: 클래스, 인터페이스 등 객체 지향 프로그래밍을 쉽게 구현할 수 있다.
- **개발 도구 통합**: 대부분의 IDE와 편집기에서 TypeScript를 지원하여, 자동 완성, 코드 탐색, 리팩토링 등의 기능을 제공한다.

**단점**

- **러닝 곡선**: JavaScript에 비해 추가적으로 TypeScript의 타입 시스템을 학습해야 하므로, 초보자에게는 러닝 커브가 존재할 수 있다.
- **폴리필 관리 필요**: 최신 JavaScript API를 구형 브라우저에서 사용하기 위해서는 별도의 폴리필 라이브러리를 직접 관리해야 한다.

<hr className="invisible mt-1" />

### 바벨

- 최신 JavaScript(ES6+) 코드를 이전 버전의 JavaScript(ES5)로 변환하여 구형 브라우저나 환경에서도 최신 문법으로 작성된 코드를 실행할 수 있게 해준다.
- `TypeScript, Vue, JavaScript, jQuery`와 같이 JavaScript를 기반으로 하는 프론트엔드 개발환경에서 널리 사용된다. 뿐만 아니라 `Node.js` 환경에서도 바벨을 사용해서 ES6 자바스크립트 코드를 실행시킬 수 있다.
- 바벨의 유연성은 다양한 플러그인과 프리셋을 통해 확장될 수 있으며, 이를 통해 `.jsx`, `.tsx` `.ts` 같은 특수 문법도 `.js` 로 변환할 수 있다.
- 바벨은 `.babelrc`나 `babel.config.js` 파일을 통해 프로젝트 별로 세밀한 설정을 할 수 있다. 이처럼 다양한 개발 환경과 요구 사항에 맞춰 사용될 수 있다.
- 바벨은 TSC와 다르게 타입 검사를 수행하지 않고 타입 관련 코드를 제거한다.

**장점**

- **광범위한 호환성**: 거의 모든 최신 JavaScript 문법을 ES5 코드로 변환할 수 있다.
- **플러그인 시스템**: 다양한 플러그인을 통해 커스텀 변환을 적용할 수 있어 매우 유연하다. 예를 들면 `@babel/core` 가 있다. 이 플러그인은 바벨의 핵심 기능을 제공하며 모든 바벨 플러그인과 프리셋은 이 패키지 위에서 작동한다.
- **폴리필 지원**: `@babel/polyfill` (혹은 `core-js`와 `regenerator-runtime`)을 사용하여 새로운 JavaScript API를 구형 브라우저에서 사용할 수 있게 해준다.

**단점**

- **타입 체크 없음**: 바벨은 코드 변환에만 초점을 맞추고 있으며, `TSC`와 같은 타입 체크나 오류 검출 같은 기능은 제공하지 않는다.
- **설정 복잡성**: 다양한 플러그인과 프리셋을 관리하고 올바르게 설정하는 것이 초보자에게는 다소 복잡할 수 있다.

<hr className="invisible mt-1" />

## 1.3 폴리필의 정의

**폴리필**은 브라우저가 기본적으로 지원하지 않는 최신 자바스크립트 API (ex: `Promise, Map, Set`)를 구현하는 코드를 제공하는 플러그인 이다. 폴리필은 최신 자바스크립트 API가 런타임에 존재하지 않을 때에만 구형 브라우저 에서도 최신 자바스크립트 API으로 작성된 코드를 실행할 수 있게 해준다.

또한 폴리필은 TSC와 바벨과 다르게  `.tsx`나 `.jsx` 파일을 `.js` 파일로 직접 컴파일하는 기능을 제공하지 않는다. 그리고 바벨은 폴리필 처럼 최신 자바스크립트 API를 변환하지 못한다.

**주의!:** 폴리필은 바벨이 변환하지 못하는 ES6+ 문법을 변환할 수 있는 것은 아니다. 폴리필은 새로운 API를 구형 환경에서 사용할 수 있게 해주는 것에 초점을 맞춰져있다.

<hr className="invisible mt-1" />

### 왜 폴리필은 최신 자바스크립트 API가 런타임에 존재하지 않을 때에만 실행되는가

예를 들어 내가 `Promise`를 사용 한다고 가정해보자. `Promise`는 ES6에서 도입된 비동기 작업을 처리하기 위한 JavaScript의 내장 객체이고, 일부 구형 브라우저는 `Promise`를 지원하지 않는다. 크로스 브라우징을 염두에 둬야할 경우에는 폴리필을 사용하면 될 것이다.

**폴리필은 `Promise`와 같은 최신 JavaScript API가 런타임(코드가 실행되는 시점)에 존재하지 않을 경우, 그 기능을 모방하는 코드를 제공한다.** 즉, `Promise`를 지원하지 않는 브라우저에서 해당 코드가 실행될 때, 폴리필은 **`Promise`와 동일하게 작동하는 함수나 객체를 생성해서, `Promise`를 사용한 코드가 정상적으로 작동하도록 한다.**

```jsx
if (!window.Promise) {
  window.Promise = PromisePolyfill
}
```

위 코드는 `Promise`가 런타임에 존재하지 않을 때만 `PromisePolyfill`을 `window.Promise`에 할당하는 간단한 예시이다. `PromisePolyfill`은 `Promise`의 기능을 모방한 코드이다. 이렇게 폴리필을 사용하면, `Promise`를 지원하지 않는 브라우저에서도 `Promise`를 사용한 코드를 실행할 수 있게 된다.

**요약:** 폴리필은 최신 자바스크립트 API (`Promise, Map, Set` 등)이 런타임에 존재하지 않을 때, 그 기능을 모방한 코드를 생성해서 구형 브라우저에서도 최신 JavaScript API로 작성된 코드를 실행할 수 있게 해준다.

<hr className="invisible mt-1" />

## 1.4 왜 바벨도 쓰고 폴리필도 써야합니까

바벨이 변환할 수 있는 ES6 문법은 대표적으로 **화살표 함수, 클래스, 템플릿 리터럴 등**이 있다. **바벨이 모든 자바스크립트 신문법을 ES5로 변환할 수 있는 것은 아니다.**

**폴리필**은 **최신 자바스크립트 API** (ex: **`Promise, Map, Set`**) 코드가 런타임에 존재하지 않는 시점에서 해당 코드를 구형 브라우저에서도 동일하게 작동하는 함수나 객체를 생성해서 호환성을 확보해준다.

> 즉, **바벨과 폴리필은 서로 구형 브라우저에서도 동작할 수 있게끔 변환할 수 있는 자바스크립트 신문법의 영역이 다르다.** 그래서 둘 중 하나만 사용하는 것 보다는 **다양한 환경에서의 호환성을 확보하기 위해서는 바벨과 폴리필을 함께 사용하는 것이 좋다.**

<hr className="invisible mt-1" />

## [예시] 1.5 TypeScript 프로젝트에서 TSC와 바벨, 폴리필을 동시에 사용하기

셋 다 사용하면 **TSC**는 타입 체크용으로, **바벨**은 `.tsx` → `.js` 변환 용도 및 ES6 문법들을 ES5 변환 용도로, **폴리필**은 구형 브라우저에서도 최신 JavaScript API를 사용할 수 있다는 장점이 있다.

대신 셋 다 사용하면 프로젝트가 복잡해질 수 있고 번들 크기와 빌드 시간이 증가할 수 있고… 그러니 필요에 따라 선택하는게 좋다.

1. 한꺼번에 다 설치하기

```jsx
npm install --save-dev typescript @babel/core @babel/preset-env @babel/preset-typescript core-js regenerator-runtime
```

1. `tsc` 세팅: `tsconfig.json` 파일에서 `"noEmit": true` 옵션을 사용한다. 이를 통해 TypeScript가 JavaScript 코드를 직접 출력하지 않도록 한다. 대신에 바벨을 통해 최종 JavaScript 코드를 생성한다.

```json
{
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "strict": true,
    "jsx": "preserve",
    "noEmit": true
  },
  "include": ["src/**/*"]
}
```

1. `Babel` 세팅: `babel.config.js` 파일을 루트 디렉터리에 생성하고, TypeScript와 폴리필을 위한 설정을 추가한다.

```json
module.exports = {
  presets: [
    [
      "@babel/preset-env",
      {
        useBuiltIns: "usage",
        corejs: 3,
      }
    ],
    "@babel/preset-typescript"
  ]
};
```

1. 빌드 스크립트 세팅 (`package.json`): `package.json`에 빌드 스크립트를 추가하여 TypeScript 파일을 먼저 바벨을 통해 컴파일하도록 설정한다.

```jsx
{
  "scripts": {
    "build": "babel src --out-dir dist --extensions '.ts,.tsx' --source-maps"
  }
}
```

이제 내킬 때 `npm run build` 으로 빌드를 하면 됩니다
