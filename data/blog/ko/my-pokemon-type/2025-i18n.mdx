---
title: '리액트 컴포넌트에 i18next 적용하기'
date: '2025-07-15'
tags: ['React', 'Zustand', 'i18next']
projects: ['My Pokemon Type']
draft: false
summary: 'React 컴포넌트에 i18next 설치 및 사용하는 법'
toc: true
---

최초 작성: 2025. 7. 15. [notion blog](https://www.notion.so/yheedev/i18n-231c7639cb4980298af7cabdc640b7ba)

<hr className="invisible my-3" />

mypkmn 마이그레이션 세팅 중 i18next 설치를 까먹었다가 다운로드 받았다

```tsx
npm install i18next react-i18next
```

이전에 다국어 지원 기능을 구현할 때 redux toolkit에서 상태 관리를 하고 유저가 선택한 언어에 따라 json 파일을 다르게 렌더링해주는 방식이었다. 이번에는 i18next를 사용해보고 싶어서 수정해보았다.

# 리덕스 툴킷 스토어를 사용한 기존 방식

[깃허브 코드](https://github.com/yheedev/mypokemontype/blob/f17fad8a7ec467cb5f6e916144a982852a813f1b/src/stores/useLanguageStore.tsx)

```tsx
import i18n from '@/i18n'
import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import { langs, getInitialLang } from '@/constants/langs'
import { LanguageStore } from '@/types/language'

export const useLanguageStore = create<LanguageStore>()(
  persist(
    (set) => {
      const initialLang = getInitialLang()
      i18n.changeLanguage(initialLang)

      return {
        lang: initialLang,
        translate: langs[initialLang],
        setLanguage: (lang) => {
          localStorage.setItem('lang', lang)
          i18n.changeLanguage(lang)
          set({ lang, translate: langs[lang] })
        },
      }
    },
    {
      name: 'language-storage',
      partialize: (state) => ({ lang: state.lang }),
    }
  )
)
```

이전에 한/영/일 3개국어를 지원하는 기능을 구현할 때에는 리덕스 툴킷을 사용해서 구현했었다.

1. 유저가 선택한 언어 상태(lang)와 번역 데이터(translations)를 별개로 스토어(languageSlice)에 보관
2. languageSlice 내에서는 직접 작성한 json 파일을 import해서 translations에 할당
3. 번역 텍스트가 필요한 컴포넌트에서 useSelector를 사용해서 `{translate.languege.Korean}` 같은 방식으로 수동 접근

이 때의 장점으로는.. 사실 잘 모르겠다 다국어 지원 경험이 처음이었기 때문에 구현하기 바빴었다

검색해보니 이런 방식은 사용자별 맞춤 메세지 (’xx님 환영합니다’ 같은건가봄..) 혹은 로딩 상태를 조합하기 좋다고 한다.

단점으로는 직접 스토어에 json 파일을 import하다보니 translations와 lang 상태가 바뀔 때마다 매번 다시 스토어에서 번역 텍스트가 필요한 컴포넌트에 다시 접근을 해야한다는 것이다.

그외에 lazy loading 지원 안 함, fallback 언어 처리는 직접 구현 필요, 상태 기반 렌더링이라 useSelector 최적화가 필요하다는 아쉬운 점이 있다.

그리고 컴포넌트에서 직접 json을 참고를 해야 하기 때문에 작성량이 많고, 유지보수가 쉽지 않다고 한다.

나 같은 경우에는 그리 작성할 내용이 많지 않았고, mypkmn 같은 3페이지의 작은 웹 앱에서는 쓰기에 나쁘지 않았던 방식이라고 생각이 든다.

<hr className="invisible my-3" />

# i18next 사용해서 구현할 방식

[깃허브 코드](https://github.com/yheedev/mypokemontype/blob/f17fad8a7ec467cb5f6e916144a982852a813f1b/src/i18n.ts)

```tsx
import i18n from 'i18next'
import { initReactI18next } from 'react-i18next'

import ko from '@/locales/ko/ko.json'
import en from '@/locales/en/en.json'
import ja from '@/locales/ja/ja.json'

i18n.use(initReactI18next).init({
  fallbackLng: 'ko',
  resources: {
    ko: { translation: ko },
    en: { translation: en },
    ja: { translation: ja },
  },
  lng: 'ko',
  interpolation: {
    escapeValue: false,
  },
})

export default i18n
```

```tsx
// components/UI/SelectorMode/index.tsx

import { useTranslation } from 'react-i18next'

export default function SelectorMode() {
  const { t } = useTranslation()
  const { lang } = useLanguageStore()
  const [mode, setMode] = useState<'offense' | 'defense'>('offense')

	return (
	<span>
	  {mode === 'offense' ? t('Mode.offenseInfo') : t('Mode.defenseInfo')}
  </span>
	)
```

1. 기존 리덕스 툴킷으로 작성한 languageSlice의 양을 줄이고, 유저가 선택한 언어 상태(lang, setLangauge)만 담당한다.
2. i18next 내부적으로 리소스에 json 파일을 등록한다. 이후 useTranslation 훅이 json 파일을 참고해서 처리한다.
3. 컴포넌트에서 사용할 때에는 `{t('Mode.offense')}` 같은 방식으로 useTranslation을 사용한다
4. 언어 변경 시 context 전체에 적용

장점으로는 번역 누락시 fallback을 자동으로 처리한다는 것, 다양한 서드 파티를 지원하는 것, SSR과 CSR 환경을 모두 대응 가능하다는 것이다. 또한 번역 파일을 namespace로 분리할 수 있고 backend, loadPath 같은 lazy loading을 지원한다. 중복 렌더링도 useTranslation 내부에서 최적화를 처리한다.

```tsx
const translate = useSelector((state) => state.language.translations)

const { t } = useTranslation()
```

리덕스에서는 언어 변경 시 translations 객체 자체가 바뀌고, `===` 비교가 실패하면 리렌더링이 이뤄진다.

i18next같은 경우에는 t() 함수에 memoized + i18next 내부에서 효율적으로 바뀐 부분만 리렌더링이 된다.

현재 프로젝트의 마이그레이션 방향인 Next.js 15 + CSR + 다국어 지원인걸 고려해서, 유저가 선택한 언어를 스토어에서 간단하게 관리하고, i18n은 다국어 리소스를 대응하는 역할으로 분리하는게 좋겠다고 판단했다.

<hr className="invisible my-3" />

# 성능 상의 유의미한 차이점이 있나요

결국 둘 다 json 번역 리소스를 사용하고, CSR 리액트 환경인걸 감안했을 때 i18n을 적용했을 때 성능적으로 나아지는게 있는지 궁금했다.

## 1. 렌더링 효율

리덕스 툴킷은 스토어를 중심으로 상태 변경이 이뤄진다. 리렌더링 트리 범위도 useSelector로 상태가 변경되면 해당 컴포넌트 전체를 리렌더링한다.

i18next는 useTranslation()에서 t() 함수 자체를 캐싱해두기 때문에 불필요한 리렌더가 덜 발생한다. useTranslation() 내부에서 context 변화 감지 후 이후에 리렌더링을 하기 때문이다. 렌더링 방식은 context 기반 메모이제이션 처리가 되기 때문에 언어가 변경되더라도 내부적으로 캐시된 컴포넌트만 리렌더링이 된다.

## 2. 메모리 효율

리덕스 툴킷 스토어에서는 3개국어 json을 모두 import했기 때문에, 예를 들어 3개국어 중 한국어만 선택해도 브라우저 메모리에는 ko.json 뿐 아니라 en.json, ja.json이 모두 올라간다. 디폴트가 한국어이므로 접속하는 동시에 그럴듯,,

i18n도 마찬가지이다. i18n.ts에서 resources에 세 언어의 json 파일을 모두 메모리에 로드한다.

만약 json 파일을 서버에서 가져오는 경우, 추가적인 라이브러리를 설치해서 lazy loading을 할 수 있다.

<hr className="invisible my-3" />

# 성능 개선을 위한 lazy loading 적용

```tsx
import Backend from 'i18next-http-backend'

i18n
  .use(Backend)
  .use(initReactI18next)
  .init({
    fallbackLng: 'ko',
    lng: 'ja', // 초기 언어
    backend: {
      loadPath: '/locales/{{lng}}/{{ns}}.json',
    },
    ns: ['translation'], // 네임스페이스
    preload: [], // 클라이언트에서는 preload 비워두기
  })
```

이렇게 세팅해두면 앱이 처음 로드될 때 ja.json만 요청되고, 이 언어의 json만 메모리에 올라갈 수 있다.

하지만 이 경우는 내 프로젝트는 클라이언트만 존재하는 프로젝트라 해당되는 사항은 아니었다.

그래서 정적 폴더에 언어 리소스를 두고 HTTP로 불러오는 방식으로 서버 없이 lazy loading을 구현해보기로 했다.

```tsx
npm install i18next-http-backend
```

그리고 기존에 json 파일들의 이름을 변경해준다

```tsx
// 기존 위치
// import ko from '@/locales/ko/ko.json'
// import en from '@/locales/en/en.json'
// import ja from '@/locales/ja/ja.json'

// json 파일들 이름 변경
/public
  /locales
    /ko
      translation.json
    /en
      translation.json
    /ja
      translation.json
```

그리고 HttpBackend를 추가해서 i18n.ts를 수정해주었다.

[깃허브 코드](https://github.com/yheedev/mypokemontype/blob/fea7638f586899bd06a6053ad9d3a6f018950d9f/src/i18n.ts)

```tsx
import i18n from 'i18next'
import { initReactI18next } from 'react-i18next'
import HttpBackend from 'i18next-http-backend'

i18n
  .use(HttpBackend)
  .use(initReactI18next)
  .init({
    fallbackLng: 'ko',
    ns: ['translation'],
    defaultNS: 'translation',
    backend: {
      loadPath: '/locales/{{lng}}/{{ns}}.json',
    },
    lng: 'ko',
    interpolation: {
      escapeValue: false,
    },
  })

export default i18n
```

기존에 직접 json을 import했던 방식을 수정하고, 초기에 한국어만 로딩하도록 변경한다. 이를 통해 메모리 절약이 가능하고, 이 방식은 Vercel의 정적 배포에 호환된다.

클라이언트만 있어도 lazy loading이 가능한지 궁금했는데 정적 파일 + i18next-http-backend로 충분히 구현이 가능하다고 한다. 왜냐하면 public 경로에서 JSON을 HTTP로 가져오기 때문이다.

이 세팅과 더불어서 useLanguageStore, types/language.ts utils/lang.ts 등을 수정하고 더이상 translation을 사용하지 않도록 수정했다.

자고 일어나서는 개발자도구 에러들 수정하고 나서 lazy loading 세팅 후 개선된 성능을 측정해서 수정해보자..
