---
title: '"JSON을 개발한게 누구인가요?"'
date: '2026. 1. 11.'
tags: ['JavaScript']
projects: ['TIL']
draft: false
summary: '취업 박람회에서 이 질문 받았을 때 어버버했던 썰 풉니다'
toc: true
---

오늘 스타트업 취업 박람회를 다녀왔다. 한 스타트업 부스의 테크리드 분과 대화를 나눌 수 있었다.

왜 프론트엔드 개발자가 되고 싶었냐는 질문을 받았는데, 시각적인 것들을 구현하는게 즐거워서라고 대답했다. 그리고 프론트엔드 개발자로 성장하기 위해 근본적인 자바스크립트 지식을 탄탄하게 다지는게 지금 필요한 일이라고 생각해서 기초를 열심히 다지고 있다고 답변했다.
이렇게 기초를 탄탄하게 잡으려는 주니어가 잘 없다면서 좋게 봐주셨다. 그래서 열심히 딥다이브나 코어 자바스크립트 라는 책으로 공부도 하고, 저자 분께 컨택을 드려서 질문을 드리기도 했다고 했다.

그 때 테크리드 분이 "오~ 그러면 혹시 JSON을 개발한게 누구인가요?" 라고 질문을 했다.

그 때 머리가 하얘져서,, "죄송하지만 지금은 기억이 나지 않습니다. 제가 기술 면접 기회를 얻게 된다면 열심히 답변을 준비하겠습니다. 딥다이브가 성경책처럼 두꺼워서 차마 다 공부하질 못했습니다." 라고 말했다

ㅜㅜ 그 답변이 최선이었을까 너무 후회가 된다. 그치만 정말 몰랐으니까,, 어쩔 수 없다. 이제라도 공부할 기회를 얻었으니 열심히 공부하자.

<hr className="invisible mt-1" />

# JSON을 개발한 사람은 더글라스 크록포드(Douglas Crockford)이다.

더글라스 크록포드는 자바스크립트 생태계 발전에 크게 기여한 1955년생의 미국인 프로그래머이자 기업가이다.
『JavaScript: The Good Parts(자바스크립트 핵심 가이드)』와 『자바스크립트는 왜 그 모양일까?(How JavaScript Works)』 책을 출판해서 자바스크립트의 좋은 부분과 나쁜 부분을 분석하고, 어떻게 자바스크립트를 더 낫게 사용할 수 있는지 설명했다. 자바스크립트 코드 정적 분석 도구인 JSLint를 만들어서 코드 스타일과 버그를 잡아내는 문화를 확산 시켰다.

## XML의 한계

```xml
// xml 예시
<?xml version="1.0" encoding="UTF-8"?>
<도서관>
  <책 id="bk101">
    <제목>프로그래밍 입문</제목>
    <저자>홍길동</저자>
    <출판사>한빛미디어</출판사>
    <출판일>2023-01-15</출판일>
    <가격>25000</가격>
    <장르>컴퓨터</장르>
  </책>
  <책 id="bk102">
    <제목>파이썬 프로그래밍</제목>
    <저자>김철수</저자>
    <출판사>정보출판</출판사>
    <출판일>2022-11-20</출판일>
    <가격>30000</가격>
    <장르>컴퓨터</장르>
  </책>
</도서관>
```

2000년대 초, 웹에서 서버와 브라우저 통신이 이뤄질 때 당시 XML 기반 프로토콜에 의존했다. XML(Extensible Markup Language)은 데이터를 태그로 감싸 계층 구조로 표현하는 마크업 언어로, “데이터의 구조와 의미를 기술하기 위한 형식”이다. HTML이 화면 표시용이라면, XML은 여러 시스템 사이에서 데이터를 정의·저장·전송하기 위한 범용 포맷이라고 보면 된다.

XML은 웹 사이트, 데이터베이스 및 타사 애플리케이션과 같은 컴퓨터 시스템 간의 정보 교환을 지원하는 마크업 언어이다. 루트 태그 하나 아래에 여러 자식 요소와 속성을 두는 형태이며, 사람과 기계가 모두 읽을 수 있는 방식이다. 사전 정의된 규칙을 사용하면 수신자가 이러한 규칙을 사용하여 데이터를 효율적으로 정확하게 읽을 수 있으므로 모든 네트워크에서 데이터를 XML 파일로 손쉽게 전송할 수 있다.

하지만 선언부, DTD, XML 스키마, 네임스페이스, 요소/속성 선택 등 개념이 다양하고, 파싱 모델이 무겁다는 한계가 있어서 XML은 무겁고 복잡하다고 평가되었다. DOM 방식으로 XML을 다루면 문서를 통째로 메모리에 올려서 트리 객체로 만들기 때문에 큰 문서는 메모리와 성능에 있어서 부담이 크다.
또한 XML을 브라우저에서 사용하려면 DOM 파서나 추가 라이브러리, 때로는 플러그인까지 필요한 경우가 많았다.

그래서 표현력과 정교함은 뛰어나지만, 단순한 API 응답과 경량의 통신에는 과하게 복잡하고 무겁다는 평가를 받았다. 이후 XML의 복잡성을 해결하고자 JSON이 등장하게 된다.

하지만 여전히 대형 엔터프라이즈 시스템, 금융 및 공공기관 등 레거시와 표준 문서 형식에서는 여전히 핵심 포맷으로 사용되고 있다. 웹 API에서는 JSON이 기본이고, XML은 특수한 용도로 사용되고 있다.

## JSON의 탄생

크록포드는 자바스크립트 코드 내에서 이미 쓰던 객체 리터럴 문법이 데이터 표현에도 충분히 쓸 수 있다는 점을 느끼고, 브라우저 기본 기능만으로 사용할 수 있는 단순한 구조화 데이터 포맷을 만들고자 했다.
크록포드와 동료 칩 모닝스타는 2001년에 자바스크립트 객체 리터럴을 이용한 메시지를 브라우저와 서버 간에 주고받는 실험을 하며 최초의 JavaScript Object Notation(JSON) 메시지를 전송했다.

2002년에 JSON.org를 만들어 문법과 예제 파서를 공개하고, 이후 RFC 4627·RFC 7159, ECMA-404 등의 표준 문서로 정리되면서 오늘날의 공식 JSON 스펙이 확립되었다.
JSON은 처음부터 “프로그램 간 구조화된 정보 전달”만을 목표로 하여, 객체(키–값 딕셔너리)와 배열이라는 최소한의 데이터 구조에만 집중한 것이 큰 차이점이다.

JSON은 자바스크립트 객체 리터럴과 거의 동일한 구조라 브라우저에서 곧바로 객체로 다루기 쉬웠고, 이후 JSON.parse/JSON.stringify가 도입되면서 더 안전하고 표준화된 방식이 되었다.

## 팀 프로젝트에서 사용했던 JSON

팀 프로젝트 `<구똑>`에서 React Query를 사용해 서버와 통신하면서, 왜 JSON 포맷이 웹 개발에 잘 맞는지를 느낀 경험이 있었다.
이 글에서는 그때의 경험을 바탕으로, React Query로 JSON 데이터를 받아와 화면에 렌더링하면서 느꼈던 편의성과 배운 점을 정리해 보려고 한다.

프로젝트에서는 REST API 서버에서 JSON 형태로 응답을 내려줬고, 클라이언트에서는 React Query의 useQuery 훅으로 데이터를 가져와 상태를 관리했다.
fetch로 응답을 받은 뒤 response.json()으로 바로 자바스크립트 객체로 변환할 수 있다는 장점이 있었다.

```js
import { BASE_URL } from '#constants/url'
import type { PageRequest, NotificationResponse } from '#types/notification'

// 알림 조회 get
export const getNotis = async (
pageRequest: PageRequest,
): Promise<NotificationResponse> => {
const query = new URLSearchParams()

if (pageRequest.lastId && pageRequest.lastId > 0) {
query.set('lastId', String(pageRequest.lastId))
}

query.set('size', String(pageRequest.size))

const res = await fetch(`${BASE_URL}/api/notifications?${query.toString()}`, {
method: 'GET',
headers: {
Accept: '*/*',
'Content-Type': 'application/json',
},
credentials: 'include',
})

if (!res.ok) {
const errorData = await res.json().catch(() => ({}))
throw new Error(errorData.message || '알림 목록 조회 실패')
}

return res.json()
}
```

- https://github.com/yheedev/guttok-front/blob/main/src/apis/notiAPI.ts

`getNotis` 함수에서 `return res.json()` 부분에서 JSON 데이터를 직접 반환하여, React Query가 자동으로 캐싱하고 컴포넌트에서는 타입만 맞춰서 받아 쓰면 되어서 로직이 단순해졌다.

React Query 훅에서는 queryFn이 `Promise<TQueryFnData>`를 반환하는데, 여기서 TQueryFnData가 곧 “알림 목록 JSON을 파싱한 타입(예: NotificationResponse)"이 된다.

결과적으로 컴포넌트 쪽에서는 data.notifications.map(...) 이런 식으로 “이미 파싱된 JSON 객체”를 바로 순회해서 렌더링하게 된다.

json 구조가 자바스크립트의 객체와 거의 비슷해서 응답을 받자마자 추가적인 변환 없이 곧바로 상태로 쓰고 렌더링을 할 수 있었다. 리액트 쿼리는 비동기 함수가 반환하는 데이터를 캐시하는 라이브러리라서, Promise가 json 객체를 반환해주면 그대로 캐시에 쌓이고, 컴포넌트에서는 타입만 맞춰서 받아 쓰면 되어서 로직이 단순해졌다.

또한 포스트맨을 사용해서 시각적으로 쉽게 볼 수 있었기 때문에 백엔드 개발자 팀원들과의 협업이 편리했다. API 명세를 주고받을 때도 JSON 포맷을 사용해서, 프론트엔드와 백엔드 간의 데이터 구조에 대한 이해가 쉬웠다. JSON 스키마를 정의해서 API 계약을 명확히 할 수 있었고, 이를 바탕으로 프론트엔드에서 필요한 데이터를 정확히 요청하고 받을 수 있었다.

### 마치며

json을 사용해본 적은 있지만 누가 만들었는지, 어떤 배경에서 탄생했는지, 현재 어떤 이점을 제공하는지에 대해서는 깊게 생각해본 적이 없었다. 이번 기회를 통해서 json이 서버와 클라이언트 간의 데이터 교환에 얼마나 중요한 역할을 하는지, 그리고 그 탄생 배경과 개발자의 의도를 이해할 수 있었다. 앞으로도 이런 기초적인 지식들을 꾸준히 쌓아가야겠다는 다짐을 하게 되었다.

### 레퍼런스

- https://aws.amazon.com/ko/what-is/xml/
- https://witch.work/ko/translations/the-rise-and-rise-of-json
- https://ko.wikipedia.org/wiki/JSON
