---
title: 'CSR, SSR 그리고 SPA'
date: '2023. 10. 9.'
tags: ['Next.js', 'React', 'TIL']
draft: false
summary: ''
toc: true
---

최초 작성: 2023. 10. 9. [notion blog](https://www.notion.so/yheedev/CSR-SSR-SPA-21b7826932994211a14ee5210dbe50c3)

<hr className="invisible mt-1" />

# 1. 전통적인 Page Lifecycle 그리고 MPA

![SPA](/static/images/til/architecture.jpg)

- 주로 `jQuery`, `PHP`가 아래와 같은 전통적인 방식의 페이지 라이프 사이클을 갖고 있다.

1. 클라이언트에서 상호작용(API 요청)이 있을 때마다 서버에 새로운 페이지 요청
2. 서버는 응답을 반환하기 위해 **전체 HTML 페이지를 다시 생성**해서 클라이언트에 보낸다.
3. 브라우저는 서버로부터 받은 새 페이지를 표시하기 위해 새로고침과 렌더링을 한다.

- 이런 방식은 매 요청마다 전체 페이지를 새로고침 하고, 클라이언트와 서버 간의 많은 데이터를 주고 받는다는 특징이 있다.
- 그렇기 때문에 리소스 측면에 손해를 보거나 사용자 경험 측면에 안 좋은 경험을 가질 수 있다.
  - 이러한 전통적인 Page LifeCycle 의 첫 번째 해결책은 `SPA`였다.

<hr className="invisible mt-1" />

## 1.1. MPA (Multi Page Application)

- MPA 패턴을 사용할 수 밖에 없는 프레임워크와 라이브러리는 주로 SSR에 중점을 둔 것들이다.
  - 대표적으로 Ruby on Rails, Django 등이 있다. (`React`, `Vue`도 MPA 패턴으로 개발이 가능하긴 하다)
- SPA는 초기에 모든 리소스를 로드하고 이후 데이터만 갱신하는 반면, MPA는 **각 페이지 요청마다 새로운 HTML을 로드**한다.
  - 이는 SPA가 부드럽고 앱과 유사한 경험을 제공하는 것과 반대가 되는 특징이다.

- MPA는 아래와 같은 페이지 흐름을 갖고 있다.

1. 여러 개의 HTML 페이지로 구성
2. 각 페이지마다 새로운 HTML을 서버에서 받아옴
3. 페이지 이동 시 전체 페이지를 새로고침

<hr className="invisible mt-1" />

# 2. SPA (Single Page Application, SPA)

- SPA 방식을 채택한 주요 라이브러리나 프레임워크로는 `React`, `Vue`, `Augular`, `Svelte` 등이 있다.
- SPA는 주로 `CSR`(Client Side Rendering) 방식을 채택했다.

- SPA는 브라우저에 처음 로드 될 때에 필요한 정적 리소스 (폰트, 이미지, SVG, HTML, CSS, JavaScript, JSON 등)를 최초 접속 시 한 번 다운로드 한다.
  - 그리고 이후 변경이 있을 때에 페이지 전체를 새로고침 하지 않고 변경된 부분만 렌더링 한다는 장점이 있다. 이는 사용자 경험 개선이라는 장점과 연결된다.
  - 하지만 이렇게 맨 처음에 모든 정적 리소스를 다운로드 한다는 점은 초기 로딩 시간이 길어지도록 하는 단점이 될 수 있다.

- SPA는 프론트엔드와 백엔드를 명확히 분리하여 개발할 수 있다.
  - SPA는 HTML, CSS, JavaScript로 구성된 클라이언트 측 애플리케이션으로 개발 → 그 후 백엔드에서 제공하는 API를 요청하고 응답하는 방식으로 데이터를 주고 받는다.
  - SSR 방식을 따르는 Next.js의 경우, BFF(Backend for Frontend) 패턴을 따른다. Next.js는 프론트엔드와 백엔드 로직을 하나의 프로젝트 내에서 개발할 수 있게 해주며, 완전히 분리되어 있지 않다고 볼 수 있다.
    - 즉, Next.js는 서버에서 실행되는 서버 사이드 코드이다. 그렇기 때문에 프론트엔드 로직 내에서 API 엔드포인트를 생성해서 호출하고 화면에 표시할 수 있다.

- 유저가 SPA 페이지에 처음 접속한 뒤에 다양한 페이지에 방문을 하더라도, SPA 페이지는 하나의 index.html 페이지만 로드한다.
  - 이는 위에서 말했듯 같은 index.html에서 JavaScript를 사용해서 현재 페이지를 계속 동적으로 업데이트하기 때문에 가능하다.
  - 이 문제는 리액트 라우터 돔 라이브러리를 사용해서 클라이언트 사이드 라우팅을 구현해서 해결할 수 있다. 이를 통해 SEO, UX를 개선할 수 있다.

<hr className="invisible mt-1" />

# 3. CSR (Client Side Rendering) / SSR (Server Side Rendering)

- 웹 애플리케이션 렌더링 방식에 따라 SEO, 리소스 사용 방식, 로딩 속도, 개발 복잡도 등이 달라질 수 있다.
  - 렌더링 방식은 CSR, SSR 외에 SSG, ISR 등 다양한 방식이 존재한다.
- `CSR`(Client Side Rendering)과 `SSR`(Server Side Rendering)은 웹 애플리케이션 전반에 적용되는 렌더링 방식이다.
- 순수 SPA 라이브러리나 프레임워크들은 대개 `CSR` 방식을 사용한다.
  - 요즘에는 SPA가 가진 장점과 SSR의 장점을 결합한 방식이 많이 사용되는 추세이다. (ex: `React` + `Next.js`)

<hr className="invisible mt-1" />

## 3.1. CSR (Client Side Rendering)

CSR의 동작 방식은 아래와 같다.

1. 서버로부터 클라이언트에 비어있는 HTML 파일을 최초로 로딩
2. 비어있는 HTML 파일 상태에 검색 엔진 크롤러가 접근할 확률이 높고, 비어있기 때문에 인덱싱 할 내용을 확인이 불가능
   - **이는 구글 검색 결과 노출에 어려워지는 결과와 이어질 수 있다.**
3. 비어있는 HTML 파일에 연결된 JavaScript 파일 로드 및 실행
4. JavaScript 코드가 실행되면서 동적으로 컨텐츠 생성 및 DOM 조작 가능

<hr className="invisible mt-1" />

**CSR의 장점**

- 유저와 상호작용에서 변경된 사항만 서버에 요청을 보내면 되기 때문에 리소스 측면에서 효율적이다.
- 사용자가 페이지를 전환할 때에 부드럽다는 느낌을 줄 수 있다.

**CSR의 단점**

- SEO가 어렵다. (빈 HTML 파일 인덱싱)
  - 맨 처음 서버에서 클라이언트로 보내는 빈 HTML 파일에 포함된 `<meta>` 태그 또한 애플리케이션의 초기 상태를 나타낸다. 그렇지만 CSR은 단일 HTML 페이지를 사용하기 때문에 페이지 내용이 변경될 때마다 `<meta>` 태그를 동적으로 업데이트하기 어렵다.
  - 이는 검색 엔진 크롤러가 SEO를 목적으로 작성된 `<meta>` 태그를 인식하지 못할 수 있다는 단점과 연결된다.
- CSR의 초기 렌더링은 상대적으로 SSR 보다 오래 걸릴 수 있다. 이는 **JavaScript 로딩과 실행 시간**에 대한 차이에서 발생하는 지연 때문이다.
  > CSR은 SSR보다 초기 전송되는 페이지의 속도는 빠르지만 서비스에서 필요한 데이터를 클라이언트(브라우저)에서 추가로 요청하여 재구성해야 하기 때문에 전제적인 페이지 완료 시점은 SSR보다 느려진다.
  >
  > [어서 와, SSR은 처음이지? - 도입 편](https://d2.naver.com/helloworld/7804182)

<hr className="invisible mt-1" />

### 3.1.1. CSR은 왜 맨 처음에 비어있는 HTML 파일을 보내나요?

- CSR(Client-Side Rendering)은 말 그대로 클라이언트가 애플리케이션의 모든 UI를 렌더링하는 방식이다. 이 방식에서 서버는 화면 구성을 하지 않고 HTML, JavaScript 제공을 주로 맡는다.
  - 이는 서버 부하를 줄이고 확장성을 높이는 데 유리하다.
- CSR에서 브라우저는 비어있는 HTML 파일을 읽고, 자바스크립트를 다운로드 및 실행한 후 화면을 동적으로 생성한다.
  - 서버에서 클라이언트로 보낸 비어있는 HTML에는 `<div id="root"></div>`와 같은 최소한의 컨테이너가 포함되어 있다.
    이는 브라우저가 자바스크립트를 통해 이 컨테이너에 애플리케이션의 UI를 동적으로 삽입할 수 있도록 설계된 구조이다.

<hr className="invisible mt-1" />

### 3.1.2. CSR =/= SPA

- CSR은 클라이언트 측에서 페이지를 렌더링 하는 방식이고, SPA는 웹 애플리케이션의 아키텍처 중 하나이다.

- **CSR**
  - JavaScript를 클라이언트에서 실행하여 동적으로 페이지를 렌더링하는 방법이다.
  - 최초에 서버에서 클라이언트로 비어있는 HTML 파일을 가져온다.
  - JavaScript가 실행되면서 페이지의 DOM을 조작하고 필요한 데이터를 동적으로 불러와서 화면에 표시한다.

- **SPA**
  - 웹 앱에서 하나의 HTML 파일만 사용한다.
  - 주로 페이지 전환 없이 동일한 하나의 HTML 파일에서 새로운 컨텐츠를 동적으로 로드하거나 렌더링한다. (이 과정을 CSR를 통해 구현하는 경우가 많다)
- HTML 파일로부터 JavaScript를 로드하거나 실행하는 역할은 CSR과 SPA 둘 다 할 수 있다.

<hr className="invisible mt-1" />

## 3.2. SSR (Server Side Rendering)

SSR의 특징은 아래와 같다.

- SPA의 단점을 보완하기 위해 도입된 방식으로, 서버가 **HTML을 미리 렌더링**하여 **완성된 페이지**를 클라이언트에 전달한다.
  - 클라이언트는 이미 렌더링된 HTML을 받기 때문에, 페이지는 빠르게 렌더링된다.
  - 클라이언트에 전달되는 렌더링된 HTML 파일에는 SEO 메타 데이터가 모두 포함된다.
    - 이는 비어있는 HTML 파일을 최초로 검색 엔진 크롤러에게 노출하는 CSR과 대조되는 장점이다. 그렇기 때문에 검색 엔진 크롤러가 컨텐츠가 렌더링된 HTML을 쉽게 읽고 인덱싱할 수 있다.
- 서버에서 페이지를 렌더링하여 클라이언트로 전송하므로 초기 로딩 시간이 빠르다.

SPA 환경의 SSR의 동작 순서 (ex: `React` + `Next.js`) 는 다음과 같다.

1. 서버에서 초기 상태와 함께 렌더링된 HTML 파일을 클라이언트에 전송한다.
   - 이 HTML에는 초기 컨텐츠가 포함되어 있다. 초기 컨텐츠에는 SEO를 위한 메타 데이터, 스타일, 텍스트, 이미지, 레이아웃 구조 등이 포함된다.
   - 이로 인해 검색 엔진 크롤러가 페이지를 쉽게 인덱싱 할 수 있다.
2. 브라우저는 해당 HTML 파일을 렌더링하여 사용자에게 즉시 내용을 보여준다. 동시에 JavaScript 파일들을 다운로드 한다.
3. JavaScript가 로드되면 브라우저는 React를 실행한다.
   - 이 과정을 hydration이라고 한다.
4. 하이드레이션 과정이 완료되면 페이지가 완전히 상호작용 가능한 상태가 된다.
5. 이후 페이지 내에서의 네비게이션은 CSR 방식으로 처리된다.

- **Next.js 프로젝트에서 명시적으로 직접 HTML 파일이 존재하지 않는 이유**는 `Next.js`가 **서버 사이드 렌더링(SSR)**을 통해 **동적으로 HTML을 생성**하고 클라이언트에 전달하기 때문이다.

<hr className="invisible mt-1" />

**SSR의 장점**

- CSR에 비해 초기 렌더링 속도가 짧다.
  - SSR은 서버에서 완성된(렌더링된) HTML을 생성하여 클라이언트로 전송하기 때문에 사용자가 브라우저에서 바로 화면을 볼 수 있다.
    > SSR을 사용하면 모든 데이터가 매핑된 서비스 페이지를 클라이언트(브라우저)에게 바로 보여줄 수 있다. 서버를 이용해서 페이지를 구성하기 때문에 클라이언트에서 구성하는 CSR(client-side rendering)보다 페이지를 구성하는 속도는 늦어지지만 전체적으로 사용자에게 보여주는 콘텐츠 구성이 완료되는 시점은 빨라진다는 장점이 있다. 더불어 SEO(search engine optimization) 또한 쉽게 구성할 수 있다.
    >
    > [어서 와, SSR은 처음이지? - 도입 편](https://d2.naver.com/helloworld/7804182)
- SEO에 효과적이다.
  - SSR은 완전한 HTML을 검색 엔진 크롤러에게 제공하기 때문에 온전히 인덱싱을 할 수 있다.

**SSR의 단점**

- CSR에 비해 서버에 부하가 많다.
  - 클라이언트 요청 마다 HTML을 동적으로 렌더링해야 하기 때문에 서버 부하가 증가한다.
- 경우에 따라 사용자가 페이지를 전환 시 화면이 깜빡거리거나 불안정하다는 느낌을 받을 수 있다.
  - 페이지 전환 시 서버에서 새로 렌더링하는 과정에서 깜빡이는 현상이 나타날 수 있음. 하지만 Hydration 또는 상태 동기화를 통해 이런 문제는 해결할 수 있다.

<hr className="invisible mt-1" />

# 4. React + Next.js (feat. SPA + SSR)

- React는 CSR 방식을 채택한 SPA 프론트엔드 라이브러리이다. 그리고 Next.js는 Vercel에서 개발한 리액트 기반의 프레임워크로, 별도의 설정을 하지 않아도 SSR, SEO 부터 TypeScript 지원까지 많은 기능들을 제공한다.
- SPA의 장점과 SSR의 장점을 합치기 위해 React + Next.js 방식을 채택하는 곳이 많다. React + Next.js 방식을 실제로 채택한 기업으로는 Netflix, Airbnb, Twitch, Github 등이 있다.

- **페이지 단위 렌더링 방식:** Next.js에서는 각 페이지별로 SSR, SSG, CSR 등 다양한 렌더링 방식을 선택할 수 있다. 이를 통해 일부 페이지는 SSR로 빠르게 렌더링하고, 나머지는 CSR로 동작하게 설계할 수 있다.
- **동적 라우팅과 SPA 전환:** Next.js는 `next/link`를 통해 클라이언트 측 네비게이션을 지원하며, SSR로 렌더링된 페이지에서도 CSR처럼 동작하도록 전환할 수 있다.
