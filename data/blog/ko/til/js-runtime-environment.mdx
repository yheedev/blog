---
title: 'Javascript 코드의 동작 구조 (런타임 환경)'
date: '2024-09-21'
tags: ['Javascript']
topics: ['TIL']
draft: false
summary: '동기/비동기, JS 엔진, 웹 API, 마이크로태스크 큐, 태스크 큐, 이벤트 루프'
toc: true
---

최초 작성: 2024. 9. 21. [notion blog](https://www.notion.so/yheedev/Javascript-107c7639cb4980cb8c64d45ad23f2605)

[이벤트 루프와 태스크 큐, var/const의 한계, 스코프, 함수형 프로그래밍](https://www.notion.so/var-const-87ddf0d1d4d04c7f9004e1352ff73d7e?pvs=21)

기술면접 2회차에서 작성했던 내용에 추가로 공부한 내용을 더해서 별도의 포스트로 작성하고 있다.

2회차의 첫 번째 질문에 등장하는 이벤트 루프, 태스크 큐를 이해하기 위해 동기와 비동기의 차이, 자바스크립트 런타임의 메모리 공간 중 콜 스택과 힙에 대해 공부했었다. 이후에 전체적인 자바스크립트 엔진의 동작 구조에 대해 추가적으로 공부했다.

<hr className="invisible mt-1" />

# 1. 동기와 비동기의 간단한 차이점

**동기**는 동시에 일어나는(synchronous) 것으로 **요청과 그 결과가 동시에 일어난다.** 요청을 하면 시간이 얼마나 걸리더라도 요청한 같은 자리에서 결과가 나타난다. 하지만 결과가 주어질 때 까지 아무 것도 못하고 대기하는 상황이 발생할 수 있다는 특징이 있다.

**비동기**는 동시에 일어나지 않는(Asynchronous) 것으로 **요청과 그 결과가 동시에 일어나지 않는다.** 요청한 그 자리에 결과가 바로 주어지지 않고 딜레이가 될 수 있다.

비동기는 결과가 주어지는데 오랜 시간이 걸리더라도 그 시간 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있다는 장점이 있다.

<hr className="invisible mt-1" />

# 2. 자바스크립트는 단일 스레드 기반의 언어

- Javascript는 싱글 스레드 기반의 언어로, Javascript 엔진은 한 번에 하나의 요청을 처리하는 **동기 방식**으로 작동한다.
- 하지만 Javascript로 동작하는 브라우저를 보는 유저 입장에서는 다양한 요청이 동시에 일어나는 것처럼 (애니메이션 효과, 데이터 요청 등이 동시에 일어나듯이) 보인다.
- **싱글 스레드임에도 여러 가지 일이 동시에 실행되는 것처럼 보이는 Javascript의 동시성은 이벤트 루프를 통해 구현된 것이다.**

<hr className="invisible mt-1" />

# 3. 런타임 환경 | 이미지

![자바스크립트 런타임 환경](/static/images/til/js-runtime.jpg)

출처: [https://vahid.blog/post/2021-03-21-understanding-the-javascript-runtime-environment-and-dom-nodes/](https://vahid.blog/post/2021-03-21-understanding-the-javascript-runtime-environment-and-dom-nodes/)

- 자바스크립트 코드를 실행하는 데에 필요한 자바스크립트 엔진, 웹 api/브라우저 api, 이벤트 루프 등 전체 시스템을 모두 포함해서 자바스크립트 런타임 환경이라고 부른다.
- 자바스크립트 엔진에 의해 코드 실행이 진행되고 있을 때, 만약에 DOM 조작, 타이머 설정, 네트워크 요청 등의 추가적인 작업이 필요하다면 런타임 환경이 이를 처리한다.

- 런타임의 위치와 역할은 자바스크립트를 브라우저에서 실행하는지, Node.js에서 실행하는지에 따라 달라질 수 있다.
  - 브라우저의 런타임 환경:
    - 자바스크립트 엔진(ex: V8)
    - 웹 API (ex: fetch, setTimeout)
    - 이벤트 루프, 콜백 대기열 및 마이크로태스크 대기열
  - Node.js의 런타임 환경
    - 자바스크립트 엔진(예: V8).
    - 비동기 I/O 작업(파일 시스템, 네트워킹 등)
    - 이벤트 루프, 콜백 대기열 및 마이크로태스크 대기열.
  - 실행 컨텍스트는 변수 객체와 스코프 체인 저장 (클로저 생성 때 외부 함수와 내부 함수 사이의 스코프 체인이 여기에 저장됨), this 바인딩 등 역할을 한다.

<hr className="invisible mt-1" />

# 4. 자바스크립트 엔진

유저와의 상호작용을 통해 이벤트가 발생한다고 가정했을 때, 이벤트 핸들러 함수가 실행되어야 할 것이다.

**이후에 이벤트 핸들러 함수 내의 자바스크립트 코드가 자바스크립트 엔진에 의해 해석되고 실행된다.** 그 이후에 자바스크립트 엔진이 코드를 실행하는 동안, 런타임 환경의 다른 곳에서 메모리 관리, 비동기 작업 처리, 웹 API 호출 등을 지원한다.

- 엔진의 예시로는 V8 (Chrome/Node.js), SpiderMonkey (Firefox), JavaScriptCore (Safari) 등이 있다.
- 자바스크립트 엔진은 코드를 해석하고 실행하는 역할을 하며, 런타임 환경은 이 엔진을 포함하여 코드 실행을 위한 다양한 기능을 제공한다.

자바스크립트 엔진 내부는 크게 `메모리 힙`과 `콜 스택`으로 나눠져있다. 그리고 `가비지 컬렉터`라는 컴포넌트도 존재한다. 이 셋은 각각 맡은 역할과 하는 일이 다르다.

<hr className="invisible mt-1" />

## 4.1. 콜 스택 (Call Stack)

자바스크립트가 싱글 스레드인 이유는 호출 스택이 콜 스택 1개이기 때문이다. 그래서 콜 스택에서는 함수를 하나씩 처리하는 것이다. 이 때문에 비동기 함수처럼 대기가 필요한 일을 처리할 때에는 콜 스택에서 모두 처리하지 않고 이벤트 루프 같은 다른 런타임 환경의 도움을 받는다.

- 콜 스택은 주로 함수 호출 및 함수의 순서 추적, 함수 실행 컨텍스트, 지역 변수 등을 관리하고 실행하는 스택 구조의 메모리이다.
- 콜 스택은 후입 선출(Last-In-First-Out, LIFO) 방식으로 가장 최근에 호출된 함수가 가장 먼저 실행되고 완료 된다.
- 콜 스택은 함수가 호출되면 해당 함수의 **실행 컨텍스트를 생성하고 스택에 추가**한다. 함수 실행이 완료되면 해당 실행 컨텍스트를 스택에서 제거한다.
- 재귀 함수는 자신을 다시 호출하는 함수로, 콜 스택은 재귀 함수 호출을 처리하기 위해 필요하다. 재귀 함수가 호출될 때마다 실행 컨텍스트가 스택에 추가되고, 재귀 함수가 종료될 때마다 스택에서 제거된다.

<hr className="invisible mt-1" />

### 4.1.1. 실행 컨텍스트 (**Execution Context)**

- 실행 컨텍스트는 콜 스택 내에 위치해있다. 실행 컨텍스트는 함수 호출 될 때마다 생성되며, 콜 스택에 쌓여 함수의 실행 상태를 관리한다. 이후에 함수가 반환되면 콜 스택에서 제거된다.
- 콜 스택의 최상단에 있는 실행 컨텍스트가 현재 실행 중인 함수의 상태를 관리한다.

<hr className="invisible mt-1" />

## 4.2) 메모리 힙 (Memory heap)

- 자바스크립트 엔진의 메모리 힙은 **객체, 배열, 함수와 같은 데이터를 저장**할 수 있는 데이터 구조이다. 메모리 힙에 저장된 데이터는 실행되는 동안 메모리에 유지된다.
- 메모리 힙의 크기는 메모리가 할당되고 해제됨에 따라 유연하게 늘어나고 줄어들 수 있다.
- 메모리 힙은 비정형 데이터 구조를 갖고 있으며 데이터가 특정 순서 없이 할당된 데이터의 크기와 수, 메모리 공간의 사용 여부 등에 따라 배치가 된다. 이는 메모리 힙이 데이터 할당 및 해제와 관련된 작업을 처리하기 때문이다.
- 메모리 힙에 저장된 데이터가 더 이상 참조되지 않으면, 가비지 컬렉터가 해당 데이터를 식별해서 해제한다. 이를 통해 메모리 누수를 방지하고 효율적으로 사용할 수 있다.

<hr className="invisible mt-1" />

엔진 내에서 콜 스택과 메모리 힙은 서로 상호 작용을 하거나 각자 다른 일을 수행하며 동작한다.

- **#1 함수 호출**: 함수가 호출됨 → 콜 스택에서 해당 함수에 대한 실행 컨텍스트를 생성 및 추가 (실행 컨텍스트 내에 함수의 지역 변수, 함수 선언 등 포함) → 해당 함수 내 객체, 배열 등은 메모리 힙이 참조함. (콜 스택이나 실행 컨텍스트가 아닌 해당 함수에서 메모리 힙이 직접 참조함)
- **#2 가비지 컬렉션**: 콜 스택에서 함수 실행 완료 후 호출 스택에서 해당 함수의 실행 컨텍스트가 제거됨 → 실행 컨텍스트가 제거되면 메모리 힙에 있는 객체나 배열에 대한 참조가 사라질 수 있음 → 가비지 컬렉터는 더 이상 참조되지 않는 객체, 배열을 식별해서 해제

<hr className="invisible mt-1" />

## 4.3) 가비지 컬렉터

- 가비지 컬렉터는 자바스크립트 엔진의 일부로, 메모리 힙이나 콜 스택 내부에 있는 것이 아니라 자바스크립트 엔진 내부에서 독립적으로 동작하는 구성 요소이다.
- 가비지 컬렉터는 메모리 힙을 관리하고, 더 이상 참조되지 않는 객체를 식별하여 메모리를 회수하는 역할을 한다.
- 가비지 컬렉터는 주기적으로 메모리 힙을 검사하고, 더 이상 참조되지 않는 객체를 식별하여 메모리를 회수한다.
- 메모리 힙에 저장된 모든 메모리를 계속 식별할 수 있도록 둔다면 메모리 누수, 성능 저하, 안정성 측면에서 문제가 된다. 그렇기 때문에 가비지 컬렉터를 통해 지속적으로 사용되지 않는 메모리가 있는지 식별하는 것이 필요하다.

- 가비지 컬렉터는 일반적으로 마크 앤 스위프 알고리즘을 기준으로 더 이상 참조되지 않는 객체를 식별한다.
  - 마크 단계: 전역 객체와 콜 스택에 있는 모든 객체에서 시작해서 도달할 수 있는 모든 객체를 마크(식별)한다. → 루트 객체에서 접근할 수 있는 모든 객체는 여전히 사용 중인 것으로 간주한다. 접근할 수 없을 경우 메모리를 회수한다.
  - 스위프 단계: 마크 단계 이후 가비지 컬렉터는 메모리 힙을 순회하며 마크되지 않은 객체를 식별하고, 이를 회수하여 메모리를 해제한다.

<hr className="invisible mt-1" />

# 5. 웹 API (Web API)

자바스크립트 런타임 환경에서 실행 중인 자바스크립트 코드 중에서 DOM API (`getElementById`), `setTimeout`, `fetch`, 이벤트 핸들러 등처럼 브라우저가 제공하는 웹 API 코드가 나타날 수 있다. 이러한 코드들은 자바스크립트 엔진이 아닌 웹 API에서 처리를 한다.

- 자바스크립트 런타임 환경 내의 웹 API는 **브라우저가 제공하는 웹 API 동기 작업과 비동기 작업을 모두** 수행할 수 있다.
- 웹 API는 브라우저가 제공하는 API로, 자바스크립트 코드가 브라우저의 기능을 활용할 수 있게 한다.
- 웹 API는 브라우저 내에 내장되어있기 때문에 브라우저 내에서만 동작한다.

- 동기 웹 API 코드는 호출되면 즉시 실행된다. (ex: DOM 조작)
  - 결과가 반환될 때까지 다음 코드의 실행을 차단한다. 이러한 동기 작업은 **콜 스택에서 바로 처리**된다.
  - 웹 API 호출도 함수 호출의 일종이므로, 웹 API 호출 시에도 실행 컨텍스트가 생성되고 콜 스택에 추가 된다.
  - 웹 API 함수의 실행이 완료되면 콜 스택에서 실행 컨텍스트가 제거된다.

- 비동기 웹 API 코드는 실제로 비동기적으로 수행된다. (ex: `setTimeout`은 지정된 시간이 경과할 때까지 기다림, `fetch`는 네트워크 요청을 처리함)
  - 웹 API에서 수행할 수 있는 비동기 작업이 완료되면, 웹 API는 해당 작업의 콜백 함수를 등록한다.

동기 웹 API 코드와 다르게 비동기 웹 API 코드는 이후 추가적으로 마이크로태스크 큐 혹은 태스크 큐로 나뉘어져서 처리된다.

<hr className="invisible mt-1" />

# 6. 마이크로태스크 큐 **(Microtask Queue)**

웹 API의 비동기 작업이 일정 부분 완료된 이후 해당 작업의 콜백 함수 중 프로미스의 `then`, `catch`, `finally` 콜백 함수와 `MutationObserver` 콜백 함수는 **마이크로태스크 큐(Microtask Queue)**에 추가가 된다.

- 마이크로태스크 큐는 태스크 큐보다 우선순위가 높다. 이후에 이벤트 루프가 태스크 큐를 처리하기 전에 마이크로태스크 큐를 먼저 처리한다. 이는 이벤트 루프가 마이크로태스크 큐의 작업을 먼저 처리하기 때문이다.
- 마이크로태스크 큐가 태스크 큐보다 우선순위가 높은 이유는 비동기 작업의 일관성과 예측 가능성을 높이고, 다른 비동기 작업 간의 순서를 유지하기 위함이다. 이는 사용자 경험을 향상시키고, 비동기 작업의 결과를 빠르게 반영하는 데에 도움이 된다.

<hr className="invisible mt-1" />

# 7. **태스크 큐(Task Queue)**

웹 API의 비동기 작업이 일정 부분 완료된 이후 해당 작업의 콜백 함수 중 `setTimeout`, `setInterval`, I/O 작업 콜백 함수,이벤트 핸들러는 **태스크 큐(Task Queue)**에 추가된다.

**I/O 작업 콜백 함수는** 파일 읽기/쓰기, 네트워크 요청 등의 I/O 작업이 완료된 후에 실행되는 콜백 함수이다. 그러면 마이크로태스크 큐에 들어가도 되지 않았나 싶었는데, I/O 작업은 일반적으로 시간이 오래 걸릴 수 있는 비동기 작업이라고 한다. 이러한 작업은 다른 비동기 작업과 구분하여 처리하는 것이 효율적이다.

<hr className="invisible mt-1" />

# 8. 이벤트 루프 (Event Loop)

이벤트 루프(Event Loop)는 이벤트 루프는 콜 스택, 마이크로태스크 큐, 태스크 큐를 관리해서 자바스크립트 런타임 환경에서 비동기 작업을 효율적으로 처리한다. 이를 통해 동기 작업과 비동기 작업들이 균형 있게 처리할 수 있도록 조정하는 역할을 한다. 그래서 단일 스레드인 자바스크립트가 한 번에 많은 태스크를 처리하는 것처럼 보이게 만들어주는 동시성을 지원한다.

- 콜 스택 관리: 이벤트 루프가 콜 스택이 비어있는지 확인 → 콜 스택이 현재 실행 중인 작업이 완료될 때까지 기다림 → **콜 스택이 비어있을 경우, 이벤트 루프는 마이크로태스크 큐와 태스크 큐를 처리한다.** (웹 API 동기 작업은 여기에 등장하지 않는다. 콜 스택에서 바로 처리하기 때문이다.)
- 마이크로태스크 큐 관리: 이벤트 루프가 콜 스택이 비어있는지 확인 → 콜 스택이 현재 실행 중인 작업이 완료될 때까지 기다림 → **콜 스택이 비어있을 경우 이벤트 루프는 마이크로태스크 큐에 있는 모든 작업이 완료될 때까지 계속 처리한다.**
- 태스크 큐 관리: (마이크로태스크 큐 관리 전체 반복) → 마이크로태스크 큐가 비어 있으면, 이벤트 루프는 **태스크 큐에서 작업을 하나씩 가져와 콜 스택에 추가하고 실행한다.** → 태스크 큐에서 작업을 하나씩 실행하다가, 마이크로태스크 큐에 작업이 생기면 마이크로태스크 큐의 작업을 우선적으로 처리한다.

<hr className="invisible mt-1" />

참고

[https://spartacodingclub.kr/blog/how-javascript-works-1](https://spartacodingclub.kr/blog/how-javascript-works-1)

https://vahid.blog/post/2021-03-21-understanding-the-javascript-runtime-environment-and-dom-nodes/
