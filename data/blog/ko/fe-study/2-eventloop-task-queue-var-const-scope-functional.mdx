---
title: '이벤트 루프와 태스크 큐, var/const의 한계, 스코프, 함수형 프로그래밍'
date: '2023. 8. 3.'
tags: ['Javascript']
projects: ['FE Study']
draft: false
summary: '자바스크립트의 이벤트 루프와 태스크 큐, var와 const 키워드의 한계, 스코프, 함수형 프로그래밍에 대한 개념 정리'
toc: true
---

최초 작성: 2023. 8. 3. [notion blog](https://www.notion.so/yheedev/var-const-87ddf0d1d4d04c7f9004e1352ff73d7e)

<hr className="invisible mt-1" />

# 1. 이벤트 루프와 태스크 큐에 대해서 알고 있나요?

연관된 블로그 포스트 [Javascript 코드의 동작 구조 (런타임 환경) ](https://www.notion.so/Javascript-107c7639cb4980cb8c64d45ad23f2605?pvs=21)

- 이벤트 루프는 콜 스택, 마이크로태스크 큐, 태스크 큐를 관리해서 자바스크립트 런타임 환경에서 비동기 작업을 효율적으로 처리합니다. 이를 통해 동기 작업과 비동기 작업들이 균형 있게 처리할 수 있도록 조정하는 역할을 합니다.
- 이벤트 루프는 콜 스택이 비어있는지 확인하고, 콜 스택의 태스크가 모두 처리될 때까지 대기하다가 마이크로태스크 큐와 태스크 큐의 태스크를 처리하는 역할을 합니다. 이 때 우선 순위는 콜 스택, 마이크로태스크, 태스크 순으로 높습니다.
- 이벤트 루프는 콜 스택 작업이 모두 완료될 때까지 기다립니다. 그리고 콜 스택이 비어있을 경우 마이크로태스크 큐를 모두 처리합니다. 마이크로 태스크 큐를 모두 처리하면 태스크 큐를 하나씩 처리합니다. 이 때 마이크로 태스크 큐에 작업이 생기면 마이크로 태스크 큐의 작업을 우선으로 합니다.
- 이는 마이크로태스크 큐가 맡고 있는 프로미스 `then`, `catch`, `finally` 의 중요성이 높기 때문입니다.

- 태스크 큐 (이벤트 큐)는 웹 API 비동기 작업 중에서 `setTimeout`, `setInterval`, I/O 작업 콜백 함수,이벤트 핸들러 등을 처리합니다. 마이크로태스크 큐보다 처리에 대한 우선순위가 낮습니다.

<hr className="invisible mt-1" />

## ✨ 피드백

- 이벤트 루프처럼 후입선출과 같은 개념과 연관이 없지만, 태스크 큐처럼 일반적으로 선입선출의 방식을 따른다면 최대한 ‘후입선출’, ‘선입선출’과 같은 단어로 쉽고 간단하게 말하는게 좋을 것 같다.
- 태스크와 태스크 큐의 환장 조합; 태스크는 작업이라고 수정하는게 조금 더 잘 들릴 것 같다.
- **참고한 팀원의 피드백**
  이벤트 루프는 콜 스택과 태스크 큐 사이에서 비동기 작업을 조율하는 역할을 합니다. 작업을 처리하는 순서는 선입선출과 같은 원칙이 존재하지 않고, 비동기 작업이 추가된 순서와 작업의 완료 여부에 따라 순서가 결정됩니다.
  이벤트 루프의 주요 역할은 총 세 가지가 있습니다.
  첫 번째로 콜 스택을 모니터링 하면서 콜 스택이 비어있을 때에는 태스크 큐에서 대기 중인 작업(콜백 함수, 이벤트 핸들러 등)을 가져와서 실행합니다.
  두 번째로 비동기 작업이 완료될 때 콜백 함수를 태스크 큐에 추가하고, 콜 스택이 비어 있으면 해당 콜백 함수를 실행합니다.
  세 번째로 이벤트 루프는 메인 스레드에서 실행되며, 메인 스레드와 함께 동작하면서 비동기 작업을 관리합니다.
  태스크 큐는 자바스크립트에서 비동기 작업과 콜백 함수를 처리하는 데에 주로 사용되며, 일반적으로 선입선출의 방식을 따릅니다.
  예를 들어 타이머가 만료 되면 타이머 콜백 함수가 태스크 큐에 추가되고, 이벤트 핸들러가 발생하고 나면 이벤트 콜백 함수도 태스크 큐에 추가가 됩니다.
  이후에 이벤트 루프가 실행 중인 콜 스택이 비어있을 때에 태스크 큐에 있던 작업을 콜 스택으로 가져와서 처리가 됩니다. 따라서, 태스크 큐는 선입선출 방식을 사용해서 비동기 작업을 처리하고, 콜 스택과 함께 이벤트 루프를 통해 비동기 작업을 조율합니다.

<hr className="invisible mt-1" />

# 2. var 키워드의 문제점은 무엇이 있나요?

- var 키워드는 변수의 중복 선언을 허용하기 때문에 동일한 변수를 여러 번 선언할 수 있습니다. 그래서 코드 양이 많아질 때 복잡해질 수 있습니다.
- var 키워드는 함수 레벨 스코프를 지원하고 블록 레벨 스코프를 지원하지 않기 때문에 의도치 않게 전역 변수가 중복 선언될 수 있습니다.
- var 키워드는 호이스팅이 발생해도 에러가 발생하지 않기 때문에 의도치 않은 오류가 발생할 수 있습니다.

<hr className="invisible mt-1" />

## ✨ 피드백

- 함수 레벨 스코프를 지원하는 동시에 블록 스코프를 지원하지 않는다는 점을 이야기해보자. 동시에 블록 스코프를 지원하는 let과 const 키워드가 var 키워드의 단점을 보완할 수 있다는 점을 말할 수 있을 것이다.

<hr className="invisible mt-1" />

# 3. const 키워드는 어떤 특징이 있나요?

- const 키워드는 재선언과 재할당이 모두 불가능합니다. 이를 통해 의도치 않은 재선언과 재할당을 방지할 수 있습니다.
- 그러나 재할당이 아닌 수정은 가능합니다. const 키워드로 객체를 선언할 경우, 객체를 수정할 수는 없지만 객체의 프로퍼티를 수정할 수 있습니다.
- const 키워드는 let 키워드처럼 블록 레벨 스코프를 지원합니다.
- const 키워드를 통해 선언한 변수는 반드시 선언과 동시에 할당을 해야 합니다.

<hr className="invisible mt-1" />

## ✨ 피드백

- const 키워드에서 변수의 재할당이 완전히 금지된다.
- 객체에 대한 변수 재할당이 금지되지만, 그것들을 참조하는 변수를 변경하는 것은 가능하다.
- const 키워드의 불변성에 대한 의견이 나왔다. 추가적으로 공부한 내용을 작성해보았다.

<hr className="invisible mt-1" />

## 3.1. const 키워드의 불변성

const 키워드의 **불변성**(immutability)은 const로 선언된 변수가 한 번 선언되면 해당 변수는 초기에 할당된 값에서 재할당을 할 수 없다는 특징을 일컫는다. 이것은 const 키워드로 선언된 변수가 상수 값을 가지고 있어야 함을 의미한다.

그러나 const 키워드를 사용해서 **객체나 배열, 함수와 같은 참조 타입**을 변수로 선언한 경우, 해당 변수가 가리키는 객체나 배열은 불변적이지 않다. 즉, const 키워드를 통해 선언한 변수의 값이 **참조 타입일 경우 수정이 가능한데, 이는 재할당과는 다른 개념이다**. 그렇기 때문에 변수 자체를 다른 객체나 배열로 재할당할 수는 없다.

```jsx
// 객체 object의 수정 예시
const person = { name: 'John', age: 30 }
person.age = 60 // 객체의 프로퍼티 수정 가능
person = { name: 'Alice', age: 25 } // Uncaught TypeError: Assignment to constant variable.
console.log(person) // { name: "John", age: 60 };

// 배열 array의 불변성 예시
const arr = [1, 2, 3]
arr.push(4) // 배열의 요소는 수정 가능
const arr // Uncaught SyntaxError: Missing initializer in const declaration
console.log(arr) // [1, 2, 3, 4]

// 함수의 수정 예시
const test = () => {
  console.log('hello')
}
test() // 'hello'

function test() {
  console.log('hi')
}
test() // "SyntaxError: Identifier 'test' has already been declared

test.customProperty = 'bye'
console.log(test.customProperty) // 'bye'
```

위의 코드 예시에서 const를 사용해서 선언된 변수가 한 번 선언되면 다른 값으로 재할당 할 수 없다. 하지만 객체 내의 속성은 변경이 가능한게 const 키워드의 불변성의 특성이다.

<hr className="invisible mt-1" />

# 4. 스코프에는 어떤 종류가 있죠?

- 블록 스코프는 중괄호로 생성하는 블록을 기준으로 범위가 구분됩니다. for, if, 화살표 함수 등을 사용할 경우를 예시로 들 수 있습니다. const 키워드와 let 키워드가 블록 스코프를 따릅니다.
- 함수 스코프로, function 키워드를 사용하는 함수 선언식, 함수 표현식으로 기준 범위가 구분 됩니다. var 키워드가 함수 스코프를 따르며, 예외적으로 var 키워드가 화살표 함수의 블록 스코프 또한 따를 수 있습니다.

<hr className="invisible mt-1" />

## ✨ 피드백

- 나만 블록/함수 스코프로 종류를 나눠서 설명하고, 다른 팀원들은 전역/지역 스코프로 종류를 나눠서 설명한거 보고 등골이 서늘했음…….
- 일단 설명은 틀린 내용 없이 준비했고, 해당 개념을 디테일한 예시와 경험과 함께 소개해보는게 좋겠다는 조언을 들었다. 또, 전역/지역 스코프를 중심으로 좀 더 정리해봤다.

<hr className="invisible mt-1" />

## 4.1. 전역 스코프와 지역 스코프로 나뉘는 스코프

스코프는 전역 스코프(Global Scope)와 지역 스코프(Local Scope)로 나뉠 수 있는데, 변수와 함수의 접근성과 유효 범위에 차이점이 존재한다.

- 전역 스코프는 가장 바깥쪽, 최상위의 범위로 전역 스코프에서 선언된 변수와 함수는 해당 코드 내에서 어디서든 접근할 수 있다.
- 다른 함수나 블록 내에서 전역 스코프에서 선언된 변수와 함수를 참조하는 것이 가능하다.
- 전역 범위에서 변수와 함수를 남용하면 변수 충돌이 발생할 수 있고, 코드 관리가 어려워질 수 있기 때문에 용도에 맞게 전역에 선언할 필요가 있다.

- 지역 스코프는 블록 기준의 범위를 일컫으며, 지역 스코프에서 선언된 변수와 함수는 해당 지역 스코프 내에서만 접근할 수 있다.
- 함수 내에서 선언된 변수는 함수가 실행 될 때에 생성되고, 함수의 실행이 종료되면 사라진다.
- 지역 스코프는 변수의 유효 범위를 제한해서 변수 충돌을 방지하고, 해당 지역 스코프 내부의 코드를 모듈화해서 관리하기 용이하게 만들어준다.

<hr className="invisible mt-1" />

# 5. 꼬리 질문) 함수형 프로그래밍이 뭔가요?

- 함수형 프로그래밍은 코드를 작성할 때에 순수 함수(pure function)를 최우선적으로 사용하며, 이를 통해 문제를 해결하는 프로그래밍 방법 입니다.
- 함수형 프로그래밍은 언제든 결과가 동일한 순수 함수를 사용할 수 있고, 불변성을 유지하며, 함수가 1급 객체와 고차 함수의 속성을 가질 수 있습니다.
- 함수형 프로그래밍은 애플리케이션을 작성할 때 부수 효과 (의도치 않은 효과, 부작용)를 방지하고 확장성, 모듈화, 높은 수준의 추상화, 재사용성, 테스트 용이성 등 많은 장점을 갖고 있습니다.
- 다만 함수형 프로그래밍을 위한 순수함수를 구현하기 위해 코드의 가독성을 해칠 수 있다는 아쉬운 점이 있습니다.
- 반복을 `for`문이 아닌 재귀를 통해 구현하는 경우가 많아, 재귀적 코드 스타일은 무한 루프에 빠질 가능성이 있으며, 깊은 재귀 호출은 스택 오버플로우를 초래할 수 있습니다.

<hr className="invisible mt-1" />

## ✨ 피드백

- 장단점을 나눠서 알려준 점이 좋았고, 함수형 프로그래밍과 객체 지향 프로그래밍과 비교 했을 때 차이점도 같이 나열했으면 더 좋았을 것 같다는 조언을 들었다.

<hr className="invisible mt-1" />

## 5.1. 객체 지향 프로그래밍 VS 함수형 프로그래밍

- 객체지향 프로그래밍(OOP)은 프로그래밍 패러다임 중 하나로, 프로그램을 개발할 때 각각의 기능을 객체라는 작은 독립적인 단위로 나누고, 이러한 객체들 간의 상호 작용을 통해 소프트웨어를 설계하고 구현하는 방식이다.
- 각 객체는 데이터와 다른 데이터를 조작하는 함수(메서드)를 포함하며, 이러한 객체들을 조합하여 복잡한 시스템을 만들어낸다.
- 객체지향 프로그래밍은 주로 복잡한 시스템을 모델링하고 설계하는 데 적합하며, 객체 간의 상호 작용을 중심으로 한다.
- 반면에 함수형 프로그래밍은 데이터 처리와 변환에 중점을 두며, 병렬 및 분산 시스템에서 유용하다.

객체 지향 프로그래밍에는 아래와 같은 개념이 존재한다.

1. 클래스(Class): 객체를 만들기 위한 템플릿이며, 데이터와 메서드의 정의를 포함한다.
2. 객체(Object): 클래스의 인스턴스로, 실제로 메모리에 할당되어 프로그램에서 사용된다.
3. 캡슐화(Encapsulation): 데이터와 관련 메서드를 하나의 단위로 묶어 외부에서 직접 접근하지 않도록 보호하는 개념이다.
4. 상속(Inheritance): 하위 클래스가 상위 클래스의 특성과 메서드를 상속받는 개념으로 코드 재사용을 촉진한다.
5. 다형성(Polymorphism): 동일한 인터페이스를 가진 객체가 다양한 방식으로 동작할 수 있는 능력이다.

<hr className="invisible mt-1" />

## 5.2. 부수 효과, 순수 함수, 1급 객체, 참조 투명성

**부수효과**는 변수의 값이 변경되는 것이다. 자료 구조를 제자리에서 수정하거나 객체의 필드값을 설정하거나 예외나 오류가 발생하며 실행이 중단되는 것 등을 가리킨다.

**순수함수**는 부수효과를 제거한 함수를 순수함수라고 부르며, 함수형 프로그래밍에서 쓰인다. 함수의 실행이 외부에 영향을 끼치지 않는다는 특징이 있다. 순수함수 자체가 독립적이며 부수효과가 없기 때문에 스레드의 안전성을 보장받을 수 있다는 장점이 있다. 스레드에 안정성을 보장받아 병렬 처리를 동기화 없이 진행할 수 있다.

**1급객체**는 변수나 데이터 구조 안에 담거나, 파라미터로 전달이 가능하거나, 반환값으로 사용할 수 있거나, 할당에 사용된 이름과 무관하게 고유한 구별이 가능한 객체를 의미한다. 함수형 프로그래밍에서 함수는 1급 객체로 취급받기 때문에 함수를 파라미터로 넘기는 작업이 가능하다.

**참조 투명성**은 동일한 인자에 대해 항상 동일한 결과를 반환해야 하고, 참조 투명성을 통해 기존의 값은 변경되지 않고 유지된다. 부작용을 제거하여 프로그램의 동작을 이해하고 예측을 용이하게 함으로써 함수형 프로그래밍을 개발하려는 핵심 동기 중 하나이다.

<hr className="invisible mt-1" />

# 2회차 회고

막연했던 자바스크립트 런타임 구조와 함수형 프로그래밍에 대해 깊게 공부할 수 있는 시간을 가질 수 있어서 유익했다. 그리고 익숙했던 var와 const 키워드에 대해 다시금 확인하고, 불변성 개념에 대해 한 번 더 짚어볼 수 있던 것도 좋았다.

또, ‘스코프에는 어떤 종류가 있죠?’ 라는 질문에 있어서 나만 블록과 함수 스코프로 나눠서 준비한 것을 깨달았을 때의 당혹감은 잊을 수 없을 것 같다. 요새에는 var 키워드를 거의 쓰지 않다시피 하니까 함수 스코프가 기본적인 개념으로 자리를 잡았을테고, 그렇기 때문에 전역/지역 스코프가 좀 더 중요한 개념일 수 있지 않을까 하는 생각이 들었다.
