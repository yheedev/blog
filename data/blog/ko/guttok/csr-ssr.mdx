---
title: '로그인(/POST) 요청 CSR/SSR/로컬 동작 과정 정리'
date: '2025. 6. 24.'
tags: ['Next.js', 'React Query', 'Vercel']
projects: ['Guttok']
draft: false
summary: '프로덕션 및 로컬 환경에서 CSR/SSR 로그인 요청이 어떻게 동작하는지 정리'
toc: true
---

![아키텍처.png](/static/images/guttok/아키텍처.png)

이번 구똑 프로젝트를 진행하면서 Next.js, React, TypeScript, React Query, Zustand, Tailwind CSS, AWS Route 53 등으로 이뤄진 클라이언트에서 서버로 요청을 보내는 과정을 정리하고자 이미지를 만들어보았다.

이미지와 화살표만으로 전체적인 흐름 파악을 통해 내가 사용한 라이브러리와 프레임워크들이 어떤 작용을 통해 서버와 통신했는지를 나타내기 어려워서 글으로 기록을 남긴다.

크게 네 가지 경우의 요청 과정을 정리하려고 한다.

1. 배포 환경에서 `CSR` 방식으로 서버 요청시 어떤 과정으로 성공하는지
2. 배포 환경에서 `SSR` 방식으로 서버 요청시 어떤 과정으로 성공하는지
3. 401 에러는 어떻게 발생하는지, 이후 클라이언트에 어떤 식으로 실패 결과가 전달되는지
4. 배포 환경과 로컬 환경에서의 CSR/SSR 서버 요청시 차이점 (+ 로컬에서는 되는데 왜 배포 환경에선 안되나요)
5. 위 내용 8줄 요약

<hr className="invisible mt-2" />

# 1. 배포 환경 CSR 방식 서버 요청: Vercel 배포 후 EC2 서버로 요청

1. 유저가 브라우저의 로그인 페이지에서 이메일과 비밀번호를 입력한 후에 로그인 버튼을 클릭한다.

```tsx
// login/page.tsx

'use client'

export default function Login() {

  const { mutate: loginMutate, isPending } = useLoginClient()

  async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault()
    const input = { email, password }
    const parseResult = loginSchema.safeParse(input)
    if (!parseResult.success) {
      setError(parseResult.error.flatten().fieldErrors)
      return
    }
    loginMutate(input, {
      onSuccess: async (user) => {
        login(user)
        setUser(user)
        await new Promise((resolve) => setTimeout(resolve, 100))
        router.push(PATH.main)
      },
      onError: (error) => {
        if (error instanceof Error) {
          setError({ general: [error.message] })
        }
      },
    })
  }

    return (
        <form
          onSubmit={handleSubmit}
          className="grid grid-cols-1 gap-0.5 px-5 mt-5"
        >
        // 이하생략

            <Button //유저가 클릭하는 버튼이 이거임
              type="submit"
              className="mt-6 w-32 h-14 text-lg rounded-2xl"
              disabled={isPending}
            >
              로그인
            </Button>
)
```

클라이언트의 코드는 위와 같다. 폼 안에 있는 로그인 버튼을 클릭하면 `handleSubmit()`가 실행되고, 이 함수를 통해 로그인 api를 클라이언트에서 요청할 수 있도록 작성한 `useLoginClient`가 사용된다.

<hr className="invisible mt-1" />

2. 리액트 쿼리로 작성한 `useLoginClient` 내부의 mutationFn이 실행된다.

mutationFn에서 fetch를 호출하여 `BASE_URL/api/users/signin`으로 요청을 보냅니다. 이때 `credentials: 'include'` 옵션을 포함하며, 브라우저가 HTTP `Set-Cookie` 헤더를 포함한 응답을 수신하고 쿠키를 저장한다.

```tsx
'use client'

// 로그인 POST api를 클라이언트에서 호출할 수 있도록 작성한 훅
export function useLoginClient() {
  const { login } = useAuthStore()
  const router = useRouter()

  return useMutation<userInfo, Error, LoginInput>({
    mutationFn: async ({ email, password }) => {
      const res = await fetch(`${BASE_URL}/api/users/signin`, {
        // fetch 호출하는 부분
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ email, password }),
      })

      if (!res.ok) {
        const errorData = await res.json()
        throw new Error(errorData.message || '로그인 요청에 실패했습니다.')
      }

      return await res.json()
    },
    onSuccess: (data) => {
      // fetch 성공 후 실행할 부분
      queryClient.clear()
      login({
        id: data.id,
        email: data.email,
        nickName: data.nickName,
        alarm: data.alarm,
      })

      toast({
        description: '성공적으로 로그인 되었습니다.',
        variant: 'default',
      })

      router.push(PATH.main)
    },
    onError: (error) => {
      // fetch 실패 후 실행할 부분
      console.error('로그인 실패:', error)
      toast({
        description: error.message || '로그인 중 오류가 발생했습니다.',
        variant: 'destructive',
      })
    },
  })
}
```

이 때 리액트 쿼리가 직접 클라이언트에서 API 요청을 하는 역할을 하지 않는다. 브라우저 내 Web API에서 EC2 서버로 Fetch 요청을 보내는데, 이 Fetch 요청을 리액트 쿼리가 감싸고 있다는 느낌이다. 그래서 응답을 받을 때 리액트 쿼리가 Fetch 후 로딩/에러/성공 처리의 결과를 관리할 수 있다.

<hr className="invisible mt-1" />

3. EC2 서버는 로그인 요청에 담긴 정보 (이메일, 패스워드)를 검증한 뒤에, EC2 서버에서 로그 **요청이 성공**할 경우, EC2 서버에서 무작위 세션 값을 생성한다.

(예: SESSION=YzRmMjk1ZDgtY2….)

EC2 서버는 Redis에 이 세션 ID를 키로 간주하고 사용자 정보를 값으로 저장한다.

<hr className="invisible mt-1" />

4. 브라우저는 EC2 서버로부터 성공적인 요청 결과를 응답한다. 이 때 응답 결과에 포함된 쿠키는 브라우저 내 네트워크 서브 시스템에 저장된다.

이후 로그인 유저만 사용할 수 있는 CRUD와 같은 API를 요청할 때에는 `credentials: 'include',` 을 사용해서 브라우저에 저장된 쿠키를 포함해서 요청을 보낸다.

<hr className="invisible mt-1" />

5. 서버 내 해당 요청이 성공했기 때문에 로그인 버튼 내 리액트 쿼리가 응답 결과 처리를 성공적으로 onSucess에 대한 내용이 수행된다.

```tsx
    onSuccess: (data) => { // fetch 성공 후 실행할 부분
      queryClient.clear()
      login({
        id: data.id,
        email: data.email,
        nickName: data.nickName,
        alarm: data.alarm,
      })

      toast({
        description: '성공적으로 로그인 되었습니다.',
        variant: 'default',
      })

      router.push(PATH.main)
    },
```

`queryClient.clear()` 를 먼저 실행해서 로그인을 위해 기존에 갖고 있던 캐시를 모두 삭제한다. 이 과정은 리액트 쿼리 함수를 통해 이전 캐시를 초기화해서 로그인 후 다시 fetch할 수 있도록 한다.

<hr className="invisible mt-1" />

6. V8 엔진에서는 OnSuccess의 `login({..})` 함수를 처리한다.

EC2 서버에서는 로그인한 유저가 마지막으로 저장한 아이디, 이메일, 닉네임, 알람 수신 여부에 대한 값을 갖고 있다. 로그인 요청이 성공할 경우 DB에 저장된 사용자 정보를 조회하고, 클라이언트에 아이디, 이메일, 닉네임, 알람 값을 포함한 응답을 반환한다.

`login({..})` 함수는 zustand로 구성된 useAuthStore에서 작성한 훅으로, login 함수에서는 `user` 정보 상태와 `isLoggedIn` 상태를 설정한다.

```tsx
// useAuthStoe.ts

interface AuthState {
  login: (user: Partial<userInfo>) => void
}

const buildUserState = (user?: Partial<userInfo>): userInfo => ({
  id: user?.id ?? 0,
  email: user?.email ?? '',
  nickName: user?.nickName ?? '',
  alarm: user?.alarm ?? true,
})

export const useAuthStore = create<AuthState>()(
  subscribeWithSelector((set) => ({
      login: (user) => {
      set({
        user: buildUserState(user),
        isLoggedIn: true,
      })
    },
)
```

그래서 `login({..})` 함수를 처리할 때 EC2 서버에서 받은 유저 정보를 `user` 객체에 저장하고, `isLoggedIn` 상태를 true로 변경한다.

이렇게 하면 로그인 후에 `user` 혹은 `isLoggedIn` 상태를 구독하고 있는 컴포넌트들을 리렌더링할 수 있다는 장점이 있다 (예: 로그인 버튼을 로그인 후 로그아웃으로 표기하기)

<hr className="invisible mt-1" />

7. 토스터 UI를 렌더링한다.

토스트 UI의 위치는 레이아웃과 동일한 계층 구조 내에서 같은 Provider 트리 안에 위치해있다. 따라서 전체 애플리케이션이 렌더링될 때 레이아웃과 토스터 UI는 함께 렌더링되면서 동시에 마운트된다.

```tsx
// src/app/layout.tsx

  return (
    <html lang="ko">
      <body>
        <ThemeProvider>
          <QueryProvider>
            <Layout>{children}</Layout>
            <Toaster />
          </QueryProvider>
        </ThemeProvider>
      </body>
    </html>
  )
}
```

토스트 UI 컴포넌트 내부에서는 useToast() 훅을 통해 toasts 상태를 구독하고 있으며, 로그인과 같은 특정 이벤트가 발생하면 toast() 함수가 호출되어서 상태가 변한다.

React는 토스터 UI의 상태 변경이 감지되면 해당 컴포넌트의 Virtual DOM을 다시 계산(diffing)하고,
변경이 필요한 부분만 실제 DOM에 최소한으로 패치(patching)한다. 이 과정을 통해 ‘성공적으로 로그인 되었습니다.’와 같은 토스트 메시지가 브라우저에 표시된다.

이때 브라우저의 렌더링 엔진(크롬의 경우 Blink)은 DOM 변경 사항을 화면에 반영하고, Toast 컴포넌트에 정의된 애니메이션 효과 (ex. fade-in, slide-in 등) 역시 함께 처리한다.

요약: React 상태 변경 → Virtual DOM diffing → 실제 DOM patching → 렌더링 엔진의 토스트 UI 컴포넌트 렌더링/애니메이션 처리

<hr className="invisible mt-1" />

8. onSuccess 내부의 `router.push(PATH.main)` 을 실행한다.

로그인 페이지에서 메인 페이지로 이동시킨다. 메인 페이지는 서버 측에서 쿠키(’SESSION’)를 검사해서 로그인 여부를 판별하고, 이에 따라 로그인 유저 전용 컴포넌트가 렌더링된다.

```tsx
// src/app/page.tsx

import { cookies } from 'next/headers'

export default async function Main() {
  const cookie = await cookies()
  const session = cookie.get('SESSION')?.value
  const isLoggedIn = Boolean(session)

  return (
    <>
      <main>{isLoggedIn ? <AuthenticatedPage initialItems={[]} /> : <UnauthenticatedPage />}</main>
    </>
  )
}
```

로그인 성공 후 서버로부터 받아온 세션을 갖고 있으면 로그인 유저 전용 페이지인 `AuthenticatedPage` 컴포넌트를, 세션이 없다면 `<UnauthenticatedPage />` 컴포넌트를 렌더링한다.

<hr className="invisible mt-3" />

## 요약

1. 로그인 버튼 클릭하면 브라우저 클라이언트에서 리액트 쿼리로 감싼 fetch로 EC2 서버에 로그인 POST 요청
2. EC2 서버는 로그인 요청에 담긴 이메일, 비밀번호 검증 후 성공일 경우 세션 생성 후 HTTP 응답 쿠키를 전송한다.
3. 브라우저에서 fetch 응답을 받고, 브라우저 내부에 쿠키를 자동으로 저장한다.
4. onSuccess 내부 처리를 위해 캐시 삭제, zustand 로그인 함수 실행, 토스트 UI 호출, 메인 페이지 리다이렉트
5. 서버 컴포넌트에서 세션 여부를 파악 후 로그인 유저 전용 메인 페이지로 리다이렉트

- CSR 방식 사용시 API 요청/응답 과정에서 Vercel 서버는 관여하지 않는다 (당연함 브라우저가 직접 요청/응답함)

<hr className="invisible mt-1" />

## 로그인 요청이 실패하면 401 에러가 어떻게 발생하나요

로그인 요청을 할 때 올바르지 않은 이메일, 비밀번호를 입력한 뒤에 로그인 API를 요청했을 때 401 에러가 발생한다.

브라우저에서 서버에 로그인 요청을 보내는 과정은 똑같으나, EC2 서 에서 로그인 검증 로직을 실행한다.

이후 올바르지 않은 이메일, 비밀번호임이 확인될 경우, EC2 서버와 Redis는 아무 상호작용이 이뤄지지 않기 때문에 세션 값이나 쿠키를 생성하지 않는다.

사용자 응답 실패에 해당하는 HTTP 401 상태 코드를 클라이언트에 응답하고 동시에 ‘아이디 또는 비밀번호가 올바르지 않습니다’ 토스트 UI가 나오도록 했다.

<hr className="invisible mt-2" />

# 2. 배포 환경 SSR 방식 서버 요청: Vercel 배포 후 EC2 서버로 요청

총 20개의 다양한 API 중 SSR 방식이 필요하다고 느껴지는 4개의 GET API만 SSR으로 구현했다. 그 중 하나인 유저가 작성한 전체 항목을 조회하는 GET API의 흐름을 작성해본다.

<hr className="invisible mt-1" />

1. 이때 브라우저는 새로운 전체 페이지 요청을 보내기 때문에, Next.js 서버는 해당 경로(`/`)에 대해 서버 컴포넌트 기반 SSR 렌더링을 다시 수행하게 된다.

이는 로그인 직후 `router.push(PATH.main)`으로 이동한 경우와 다르다. 그 경우는 CSR이므로 서버 컴포넌트가 다시 렌더링되지 않으며 SSR 요청도 발생하지 않는다.

Vercel 서버는 새로고침으로 인해 서버 컴포넌트와 함께 `getItems()` 함수를 실행해 유저 데이터를 EC2로부터 받아오고, 해당 데이터를 바탕으로 HTML을 서버에서 생성해 브라우저에 응답한다.

<hr className="invisible mt-1" />

2. Vercel 서버는 브라우저에서 요청을 받으면 메인 페이지 경로에 대응되는 앱 라우터 메인 페이지를 SSR로 렌더링한다.

```tsx
// src/components/Main/AuthenticatesServer.tsx

'use server'

import AuthenticatedPageClient from './AuthenticatedPage'
import { getItems } from '#apis/subscriptionAPI'

export default async function AuthenticatedPageServer() {
  const itemsData = await getItems()

  return <AuthenticatedPageClient initialItems={itemsData.contents} />
}
```

```tsx
// 구독서비스 조회 GET (/)
'use server'
// 구독 목록 조회 / knownServices 구독 서비스 리스트

import type { SubscriptionContents } from '#types/subscription'
import { BASE_URL } from '#constants/url'
import { cookies } from 'next/headers'
import { PageRequest, fetchNotiRequest } from '#types/notification'

export async function getItems(pageRequest: PageRequest = fetchNotiRequest) {
  const query = new URLSearchParams({
    lastId: String(pageRequest.lastId),
    size: String(pageRequest.size),
  })

  const session = (await cookies()).get('SESSION')

  if (!session) throw new Error('세션 없음')
  console.log(session.value, 'fetching user info from')

  const res = await fetch(`${BASE_URL}/api/subscriptions/user?${query.toString()}`, {
    cache: 'no-cache',
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      Cookie: `SESSION=${session.value}`, // 여기에 세션 포함!!!!!!!!!!!!!!!
    },
  })

  if (!res.ok && res.status === 401) {
    throw new Error('로그인 세션이 만료되었습니다. 다시 로그인해주세요.')
  }

  if (!res.ok) {
    throw new Error('구독 항목 불러오기 실패')
  }

  return res.json()
}
```

SSR로 렌더링하는 과정에서 서버 컴포넌트 내부에서 실행되는 getItems()과 getItems() 내부의 cookies() 는 서버에서 실행된다.

<hr className="invisible mt-1" />

3. Next.js 서버 컴포넌트에서 실행된 fetch는 Vercel에서 EC2 서버로 API 요청을 보낸다.

이 때 CSR과 다르게 리액트 쿼리는 사용되지 않고, Node.js 환경의 fetch만으로 요청을 보낸다. 그래서 API 요청 성공/실패 결과는 onSuccess와 같은 리액트 쿼리 속성이 아닌 다른 것을 사용해서 처리해줘야 한다.

내가 SSR로 사용한 API들의 경우 대부분 조회(검색, 마이페이지 이동, 메인페이지 이동 등)가 대부분이여서 다른 API들처럼 토스터 UI를 사용할 필요는 느끼지 못했다. 그래서 SSR의 경우 토스터 UI가 사용되지 않는다.

CSR과 다른 점 두 번째로는 브라우저가 아닌 Vercel이 EC2 서버로 요청을 보내는 구조라는 것이다.

<hr className="invisible mt-1" />

4. EC2 서버는 세션을 Redis에서 검증하고, 유저가 작성한 항목 json을 반환한다.

<hr className="invisible mt-1" />

5. Vercel이 EC2 서버로부터 받은 json을 기반으로`<AuthenticatedPageClient initialItems={...} />`를 포함한 HTML을 완성한다.

브라우저에는 SSR된 HTML이 최초로 전달되어서 페이지의 기본 UI를 그린다. 이 때 useEffect, 이벤트 핸들러, 상태 관리는 동작하지 않는다.

<hr className="invisible mt-1" />

6. 브라우저에서 vercel에서 함께 보낸 로그인 유저 전용 메인 페이지의 클라이언트 컴포넌트인 `AuthenticatedPages` 의 자바스크립트 코드가 브라우저에서 실행된다.

React의 hydration은 diffing(Virtual DOM 비교)이 아니라, SSR로 생성된 DOM에 이벤트 핸들러 및 상태 관리 연결 작업만 수행한다. 즉, 서버에서 생성된 HTML을 그대로 유지하면서 상호작용을 붙인다.

<hr className="invisible mt-1" />
```tsx // src/components/Main/AuthenticatedPage.tsx

'use client'

import { Button } from '#components/_common/Button'
import { PATH } from '#app/routes'
import Link from 'next/link'
import ItemList from '#components/ui/itemList'
import { Plus } from 'lucide-react'
import { getGreeting } from '#hooks/getGreeting'
import { useGetUserInfoClient } from '#apis/userClient'
import { useCurrentMonthPaymentTotal } from '#hooks/useTotalPayment'

export default function AuthenficatedPage({ initialItems }: { initialItems: any[] }) {
  const { getUserInfoClient, isLoading } = useGetUserInfoClient()
  const monthlyTotal = useCurrentMonthPaymentTotal()

useEffect(() => {
getUserInfoClient()
}, [])

return (

<div className="mx-auto flex min-h-[calc(100vh-4.5rem)] flex-col p-4 pb-[3rem]">
<div className="mt-3 mb-6 flex justify-between">
<div className="flex flex-col">
<h1 className="flex flex-row text-xl font-semibold">{getGreeting()}</h1>
<h2>
이번 달 지출은 <span className="font-bold">₩{monthlyTotal.toLocaleString()}</span>{' '}
입니다.
</h2>
</div>
</div>

      <div className="mb-9 flex-1 overflow-auto">
        <ItemList />
      </div>

      <div className="fixed right-4 bottom-[5.5rem] flex h-14 transform items-center justify-center rounded-full shadow-lg sm:right-10 sm:bottom-[3rem]">
        <Link href={PATH.itemAdd} aria-label="구독 아이템 추가 페이지로 이동">
          <Button className="flex h-16 w-16 items-center justify-center rounded-full shadow-lg">
            <Plus size={48} />
          </Button>
        </Link>
      </div>
    </div>

)
}

```

7. useEffect, zustand와 같은 리액트 훅이 실행된 뒤에 getUserInfoClient (유저가 작성한 항목 조회 클라이언트 훅)를 실행한다. 이후 `useCurrentMonthPaymentTotal()` 같은 커스텀 훅도 동작하여 필요한 상태를 구독한다.

이 시점부터는 클라이언트 컴포넌트들의 hydration 과정이 끝나고 서버 컴포넌트와 클라이언트 컴포넌트가 각자 역할을 분리해서 작동하기 시작한다.


<hr className="invisible mt-1" />

8. 렌더링이 완료된 뒤에 버튼과 같은 상태 기반 UI가 완전히 작동한다. 리렌더링이나 기존에 원래 있던 스켈레톤 UI 등을 리액트가 제어한다.

<hr className="invisible mt-3" />

## 요약

1. 메인 페이지에서 새로고침하면 브라우저에서 Vercel에 SSR 방식으로 GET 요청을 전송
2. Vercel의 Next.js 서버가 서버 컴포넌트를 기반으로 SSR을 수행한다.
3. SSR 중 `getItems()` 함수가 실행되어, EC2 백엔드로 fetch 요청을 보낸다.
4. EC2는 Redis에 저장된 세션 쿠키를 검증하고 JSON 데이터를 Vercel 서버에 응답한다.
5. Vercel은 해당 데이터를 포함한 HTML을 완성해 브라우저에 응답한다.
6. 브라우저는 HTML을 렌더링하고, 이후 클라이언트 JS가 Hydration되어 작동함.

- SSR 방식 사용 시 브라우저에서 Vercel 서버가 클라이언트와 서버 사이에 위치해서 api 요청 과정에 관여한다.

<hr className="invisible mt-3" />

# 3. 로컬 환경에서 CSR/SSR 요청: npm run dev + docker 서버

이번 팀 프로젝트를 개발하면서 가장 힘들었던 점은 배포 환경과 로컬 환경의 간극이 너무 크다는 점이었다.

예를 들어 로컬에서는 API 요청이 성공적으로 이뤄지는데 배포 환경에서는 500 에러가 발생하는 일이 너무 비일비재했다.

그래서 로컬 환경과 배포 환경의 차이점을 파악하기 위해 로컬 환경과 배포 환경시 CSR 요청할 때 어떤 차이점이 있는지 정리해두려고 한다.

<hr className="invisible mt-1" />

## 로컬에서는 API 요청이 되는데 배포에서는 안되었던 이유

1. CSR의 경우 `credentials: true` 로 쿠키를 포함한 api 요청이 필요했다.

SSR에서는 `import { cookies } from 'next/headers'` 로 cookies를 가져온 뒤에 headers 내부에 쿠키를 포함해주었다.

2. EC2 서버에서 HTTP만 지원했었기 때문이었는데 백엔드 개발자 팀원의 Nginx 일부 수정으로 고칠 수 있었다. 비슷한 사례로 쿠키에서 SameSite, Secure 체크, HttpOnly 등 추가 설정이 필요했다

<hr className="invisible mt-1" />

## 로컬에서 CSR 요청 과정

1. 로컬 환경 구동

VSCode 터미널에서 `npm run dev` 명령어를 실행하면, Next.js 개발 서버가 실행된다. 내부에서 터보팩이 동작하여 내가 작성한 ts/tsx 파일들을 js로 트랜스파일하고, 파일 변경 사항을 감지해 HMR(Hot Module Replacement)을 제공한다.

브라우저에서 `localhost:3000`에 접속하면, Next.js dev 서버가 각 페이지에 필요한 JS 번들와 정적 자산을 실시간으로 생성하여 클라이언트에 전달한다. 브라우저는 이를 받아 React 앱을 실행하고, 이후 Hydration 과정을 거쳐 인터랙션이 가능해진다.

브라우저 내에서 리액트 앱이 실행되기 시작하며, API 요청도 브라우저 내에서 실행된다.

도커 서버를 켜기 위해 Docker Desktop을 실행한 후, 백엔드 개발자가 전달한 프로젝트 폴더(app, db, .env, docker-compose 포함)에서 터미널을 열어 `docker compose up -d` 명령어를 실행한다. 이 과정에서 백엔드 서버와 DB 컨테이너가 로컬에서 실행되며, 백엔드 API는 일반적으로 `localhost:8080`에서 서비스 된다.

이후 프론트엔드에서 CSR 요청을 보내면, React Query의 `mutationFn`이 실행되며 API 요청이 `localhost:8080`으로 전송된다. 이 요청은 배포 환경과 다르게 로컬에서는 Docker 컨테이너 내 백엔드로 전달된다.

<hr className="invisible mt-1" />

2. 브라우저가 도커 서버로 CSR 요청을 성공하면, 도커 서버는 `Set-Cookie` 헤더를 포함한 응답을 브라우저에 반환한다. 브라우저는 해당 쿠키를 자동으로 저장하며, 이후 동일 도메인(origin)이나 CORS 설정이 허용된 요청에 해당 쿠키를 함께 전송한다.

<hr className="invisible mt-1" />

3. 로그인 응답 이후, `onSuccess` 에 작성해둔 상태 관리 로직이 실행된다. `login({...})` 함수가 zustand의 `useAuthStore`의 상태를 업데이트하며, 이에 따라 `isLoggedIn` 상태를 구독 중인 컴포넌트들이 리렌더링되고, 사용자 로그인 UI로 전환된다.

이후 페이지 이동이나 기본 진입 시에는 CSR 방식으로 작동한다. 즉, Next.js 개발 서버는 초기 HTML과 JS 번들만 제공하며, 클라이언트에서 React 앱이 실행되어 필요한 데이터를 API를 통해 가져와 렌더링한다.

<hr className="invisible mt-1" />

## 로컬 환경에서 SSR 요청 과정

1. 로컬 환경은 위와 같이 `npm run dev`, `docker compose up -d` 로 구동한다.
<hr className="invisible mt-1" />
2. 마이페이지에 접속한다고 가정해보자. 이 때 브라우저는 `localhost:3000/mtpage`로 GET 요청을 보낸다. 이 요청은 Next.js 개발 서버가 받는다.
<hr className="invisible mt-1" />
3. mtpage/page.tsx 에서 getItems() 서버 사이드 함수가 실행된다. Next.js dev 서버는 서버 컴포넌트를 기반으로 SSR을 수행하고, getItems() 내에서 fetch를 실행해서 도커 서버에 요청을 보낸다.

- 요청은 브라우저 → Next.js dev 서버 → 도커 서버의 순서로 요청이 이뤄진다.
<hr className="invisible mt-1" />
4. 도커 백엔드 서버는 Redis에 저장된 세션 쿠키를 검증하고 DB 조회를 해서 데이터를 조회한 뒤, 해다 ㅇ요청에 필요한 데이터를 Next.js 개발 서버에 응답한다.
<hr className="invisible mt-1" />
5. Next.js dev 서버는 응답받은 데이터를 바탕으로 HTML을 구성해서 브라우저에 응답한다.
<hr className="invisible mt-1" />
6. 브라우저는 Next.js dev 서버에서 받은 해당 HTML을 렌더링하고, 클라이언트 js가 hydration되면서 리액트 앱에서 인터랙션이 가능해진다.

- 응답도 도커 서버 → Next.js dev 서버 → 브라우저 순서로 이뤄진다.

- 로컬에서 vercel은 아무 역할도 하지 않는다. vercel이 SSR 요청시 개입하는건 배포 환경 뿐이다. 왜냐하면 `npm run dev` 로 직접 로컬 환경에서 Next.js 개발 서버를 실행시켰기 때문이다.
- 브라우저가 도커 서버에 직접 요청하지 않고, Next.js dev 서버가 중간에서 SSR + API 호출을 대신한다.
<hr className="invisible mt-1" />

# 5. 전체 내용 8줄 요약

1. 배포 환경 CSR: 브라우저 ↔ EC2 서버로 직접 응답, 요청 후 브라우저에서 onSuccess 내용 처리
2. 배포 환경 SSR: 브라우저 → Vercel → EC2 서버로 요청. EC2 → Vercel → 브라우저 순서로 응답. Vercel이 클라이언트와 서버 사이에서 API 요청에 관여한다.
3. 로컬 환경 CSR: 브라우저 ↔ 도커 서버 직접 요청 및 응답
4. 로컬환경 SSR: 브라우저 → Next.js dev 서버 → 도커 서버로 요청. 도커 서버 → Next.js dev 서버 → 브라우저 순서로 응답. Vercel 대신 로컬에서 실행한 Next.js dev 서버가 API 요청에 관여.
5. 왜 로컬에선 되는데 배포에선 API 요청이 안되나요: CSR은 `credentials: true`, SSR은 headers 내부에 쿠키 추가. 그외 쿠키 설정에서 SameSite, Secure 체크, HttpOnly 등 추가 설정하는게 필요함.
```
