---
title: '가상 요소 ::after와 가상 클래스 :hover의 차이점'
date: '2023-06-04'
tags: ['Publishing']
topics: ['TIL']
draft: false
summary: ''
toc: true
---

최초 작성: 2023. 6. 4. [notion blog](https://www.notion.so/yheedev/after-hover-c7ccacc1add64f69aa052becdb92c36e)

예전에 가상 요소, 가상 클래스가 헷깔려서 유튜브 빔캠프 강의 영상을 보고 정리했던 내용을 다시 포스트한다.

[https://youtu.be/wTUMrLAbREo](https://youtu.be/wTUMrLAbREo)

<hr className="invisible mt-1" />

# 1. 가상 요소

```html
<div class="box">
  <span class="counter">0</span>
  <a class="button plus">+</a>
</div>
```

위 코드에서 `+` 버튼을 누르면 숫자가 증가한다고 가정해보자.

숫자 옆에 `cm` 라는 단위를 붙이고자 해서 `0cm` 라고 바꿔보았지만 `+` 버튼을 누르면 `cm` 는 없어지고 숫자만 증가하는 것을 볼 수 있다. 이는 counter 클래스 전체가 새로고침 되고 교체가 되는 방식이기 때문이다.

이 때 cm 부분을 대체하기 위해 사용하면 좋은 것이 가상요소이다.

가상 요소란 **실제 마크업에는 존재하지 않고 가상으로 존재하는 요소이다.** DOM 요소에 해당하지 않기 때문에 Javascript로 제어할 수 없다. 가상 요소는 검색엔진이나 스크린 리더기에 반응하지 않기 때문에 웹 접근성을 신경 쓰고 사용해야 한다.

가상 요소는 IE 6, 7버전에서 지원하지 않는다. CSS에서 작성한 것이기 때문에 순수하게 요소 내의 컨텐츠를 꾸미기 위한 목적은 존재하지만 중요도가 떨어지는 것을 만들 때에 쓰인다.

```css
.counter:after {
  content: 'cm';
}
```

```html
<span class="counter"> "0" ::after </span>
```

위 예시의 HTML 코드의 counter 클래스 내부에 after라는 요소가 속해있는 상태이다. content 속성을 통해서 가상 요소를 통해 나타내고자 하는 내용을 작성할 수 있다.

가상 요소를 처음 접하는 사람들은 `counter:after` 라고 작성되어 있기 때문에 `<span class="counter">` 요소 다음에(after) 가상 요소인 after, 그러니까 `cm`가 오는 것으로 헷깔리기도 한다. 하지만 부모 요소인 counter 클래스의 컨텐츠인 `"0"` 이후에 after인 `cm`가 **counter의 자식 요소로 생성되는 것을** 확인할 수 있다.

```css
.counter:before {
  content: '약';
}

.counter:after {
  content: 'cm';
}
```

```html
<div class="box">
  <span class="counter"> "0" ::after </span>
</div>
```

새로고침을 하고 나면 **약 0cm** 라고 잘 뜨는 것을 확인할 수 있다.

after와 함께 자주 쓰이는 before 또한 counter 클래스의 자식 요소로 생성된 것을 확인할 수 있다. 이 둘의 차이는 생성 요소 시점만 다르다. 개발자 도구에서 "0"이 before와 after 사이에 끼워져 있는 것 또한 확인할 수 있다.

가상 요소는 Pseudo-element, 가상 선택자, 가상 엘리먼트 등 다양한 이름으로 불리우고 있다. 가상은 virtual이 아닌 pseudo 허위, 가짜라는 단어에서 따왔다고 한다. 가상 요소는 위 예시에서 본 것처럼 대표적으로 `:after, :before` 가 있다.

<hr className="invisible mt-1" />

# 2. 가상 클래스

콜론 1개만 사용하는 `:hover` 는 가상 요소가 아닌 가상 클래스 Pseudo-class 이다. `:hover`는 가상 요소가 아닌 가상 클래스다. 가상 요소와 다르게 **실제로 존재하는 요소에 특정 이벤트나 환경에 맞춰 가상으로 클래스를 부여해서 CSS로 제어가 가능하다.**

가상 클래스 `:hover`는 요소에 커서를 올릴 때에 색깔이 변하는 효과를 줄 때 자주 쓰인다. hover를 사용하면 자바스크립트나 불필요한 클래스 사용없이 간단하게 CSS를 제어할 수 있다는 장점이 있다. 이러한 효과를 사용할 때에는 꼭 `hover -> focus -> active` 순서대로 가상 클래스를 부여한다.

```css
:any-link/*방문 전, 방문 후 링크 한번에 선택할 때*/
:playing /*동영상, 음성이 재생중일 때*/
:paused /*동영상, 음성이 정지시*/
:autofill /*input의 자동채우기 스타일*/
:disabled /*disabled된 요소 스타일*/
:checked /*체크박스나 라디오버튼 체크되었을 때*/
:blank /*input이 비었을 때*/
:valid /*이메일 input 등에 이메일 형식이 맞을 경우*/
:invalid /*이메일 input 등에 이메일 형식이 맞지 않을 경우*/
:required /*필수로 입력해야할 input의 스타일*/
:nth-child(n) /*n번째 자식 선택*/
:first-child /*첫째 자식 선택*/
:last-child /*마지막 자식 선택*/
```

<hr className="invisible mt-1" />

# 3. 싱글 콜론과 더블 콜론을 다르게 사용해서 구분한다

CSS 2.1버전에서는 가상 요소와 가상 클래스 선택자를 둘 다 콜론 1개로 사용해서 구분 없이 사용해왔다. 하지만 CSS 3 버전에서는 가상 요소는 `::after, ::before` 그리고 가상 클래스 선택자는 `:hover`와 같이 작성해서 가상 요소에 더블 콜론을 사용해서 구분 짓기 시작했다. 그래서 이제는 `:after`라고 작성을 해도 개발자 도구에서는 자동으로 `::after` 라고 고쳐지게 된다.

하지만 아직도 간혹 `:after`로 작성된 가상 요소가 있는데, 이는 IE 6, 7, 8 과 같은 하위 브라우저의 호환을 위한 조치이다. 이러한 크로스 브라우징의 의도가 없다면 `::after` 으로 작성하는 것을 지향하는 것이 좋을 것 같다.

<hr className="invisible mt-1" />

## **예제: 가상 요소의 내용을 HTML에서 수정하기**

위 코드 예시에서 만들었던 숫자를 증가시키는 `+` 버튼에 커서를 갖다대면 툴팁이 뜨도록 `:hover` 기능을 사용해보았다. 여기서 툴팁은 `+`버튼에 커서를 올리면 보이고, 평소엔 보이지 않는 기능이다.

```css
.button:after {
  content: '툴팁';
  background-color: orange;
  color: white;
  position: absolute;
  left: 0;
  top: 0;
  font-size: 12px;
  padding: 0 1em;
  white-space: nowrap;
  border-top-left-radius: 50px;
  border-top-right-radius: 50px;
  border-bottom-right-radius: 50px;
  opacity: 0.1;
  transition: all 1s 0.5s;
}

//hover가 되었을 당시의 after 요소
.button:hover:after {
  opacity: 1;
  top: -20px;
  left: 10px;
}
```

`.button:hover`는 새로운 요소가 아니다. 커서가 올라가면 버튼에 가상의 클래스가 붙도록 버튼의 상태가 잠시 바뀌는 것이다. 즉 `.button:hover`는 브라우저가 제공하는 가상 클래스이다.

`.button:hover:after` 은 버튼에 커서가 올라간 다음을 뜻한다. 이 때에 툴팁의 opacity 속성의 값을 1으로 줘서 선명하게 보이고, top 값이 생기므로 위치가 좀 더 올라간다. `.button:after`에 있는 transition 속성 때문에 툴팁이 스무스하게 움직일 수 있게 된다.

<hr className="invisible mt-1" />

![](/static/images/til/pseudo.png)

툴팁의 내용인 ‘툴팁’이 가상 요소의 content 속성에 작성되어 있으면 유지보수에 어려움을 겪을 수 있다. 버튼의 내용은 html 코드의 a태그 속성에서 작성하는 것이 낫다.

```html
<div class="box">
  <span class="counter">0</span>
  <a class="button plus" title="툴팁입니다만">+</a>
</div>
```

```css
.button:after {
  /* content: '툴팁'; */
  content: attr(title);
}
```

위 코드처럼 이용해서 content 속성에 a 태그 속 title 속성을 가져온다. 새로고침하면 title 속성 속 내용 ‘툴팁입니다만’이 잘 나오는 것을 확인할 수 있다.

이제 content에 내용을 입력하지 않아도 a 태그 속 title 속성 내에 쓴 내용으로 바뀐다. 이제 유지보수를 할 때에는 HTML 코드 내의 a 태그에서 내용 수정을 하기 때문에 간편해졌다.

<hr className="invisible mt-1" />

## 제이쿼리에서 가상 요소가 효율적으로 사용되는 사례

이펙트 메서드

```
.fadeIn(`숫자`)
.fadeOut(`숫자`)
.animate(`객체`, `숫자`, `문자`)
.stop()
.delay(`숫자`)
```

마크업 추가/변경

```
.remove()
.addClass(`문자`, `숫자`, `문자`)
.removeClass(`문자`, `숫자`, `문자`)
.toggleClass(`문자`, `숫자`, `문자`)
.attr(`문자`, `문자`)
.css(`문자`, `문자`)
.text(`문자`)
```

이벤트 메서드

```
.click(`함수`)
.hover(`함수`, `함수`)
```

메소드들은 대부분 가상 요소로 처리를 한다. 실제 마크업에는 존재하지 않기 때문에 유지 보수나 협업할 때에 편리하다는 장점이 있다.
