---
title: '동적 라우팅: slug, […slug], [[…slug]]'
date: '2025. 07. 17.'
tags: ['Next.js', 'TIL']
draft: false
summary: 'segment, dynamic route, catch-all, optional catch-all의 개념과 사용 예시 정리'
toc: true
---

[id]를 사용해서 CRUD의 조회/수정/삭제를 구현한 적이 있긴 하지만 그 외에 다른 것들은 깊이 있게 공부한 적이 없다. 이번에 모든 차이점들을 정리해서 포켓몬 타입 계산기 마이그레이션에서 적합한 것을 선택하고자 공부하고 정리해둔다.

<hr className="invisible mt-1" />

# 1. segment

세그먼트는 url 경로를 `/` 기준으로 나눈 각각의 조각(segment)을 뜻한다.
next.js 앱 라우터의 파일 시스템 기반 라우팅에서, app/ 폴더 하위의 각 폴더들이 세그먼트를 의미한다.

````mdx
```text
src/
└── app/
    └── [lang]/
        └── blog/
            └── [slug]/
                └── page.tsx
```
````

위에 있는 예시의 구조에서는 app과 blog는 폴더 명 그대로 URL 경로로 매핑되는 정적 세그먼트에 해당한다.
그리고 `[lang]`, `[slug]` 같이 URL에서 값을 추출해서 사용하는 경로는 동적 세그먼트에 해당한다.

<hr className="invisible mt-1" />

# 2. 동적 라우트 (dynamic route)

파일명에 `[ ]` 를 사용해서 변수 형태로 url 경로를 정의하는 형태를 말한다.

`[slug]` , `[...slug]`, `[[...slug]]` 모두 동적 라우트의 설계 방식에 속한다.

```mdx
src/app/[lang]/page.tsx -> /en
src/app/[lang]/defense/page.tsx -> /ko/defense
src/app/[lang]/more/page.tsx -> /ja/more
```

위 예시에서 `[lang]` 은 en, ja, ko 3개의 언어 값을 지원하며, 유저가 선택한 언어에 맞는 번역이 이뤄지며 url이 바뀐다. 여기서 사용한 `[lang]`이 단일 동적 세그먼트에 해당한다.

<hr className="invisible mt-1" />

## 2-1. `[slug]` : Dynamic Segment

메탈 슬러그 게임의 그 slug와 동일한 스펠링이지만 의미는 조금 다르다.
slug는 url 경로에 들어가는 문자열 식별자로, 공백이 없는 텍스트 기반의 고유 식별자를 사용한다.
next.js에서 slug에 대소문자나 특수문자를 사용해서 작성하는건 기술적으로 가능하긴 하지만, SEO와 URL 안정성을 위해 소문자와 하이픈을 사용해서 작성하는게 권장된다.

`[id]`와 `[slug]` 는 동일한 기능을 수행한다. 꼭 slug나 id가 아니더라도 product, path, lang 등 용도와 의도에 맞게 다양하게 이름을 작명할 수 있다. slug를 용도에 맞게 잘 작성하면 가독성 뿐 아니라 SEO를 향상시킬 수 있다는 장점이 있다.
ex: `/lang/defense`, `/feed/subscriptions`

모든

```tsx
// 예시
https://www.coupang.com/vp/products/202212224?itemId=591147832&vendorItemId=4548053809&q=%EC%9A%B0%EC%9C%A0&searchId=6234a7df4989137&sourceType=search&itemsCount=36&searchRank=1&rank=1
```

`[id]`는 주로 식별자나 숫자 기반 경로에서 사용되며, 내부 DB에서 레코드를 조회하거나 수정할 때 사용된다. 가독성이 떨어지지만 정확한 내부 식별자를 통해 특정 데이터를 타게팅해서 보여주기 위해 사용하기에 좋다.

나 같은 경우에는 구똑 프로젝트에서 CRUD 구현을 하면서 조회/수정/삭제를 구현하기 위해 `[id]` 경로를 사용해서 유저가 조회/수정/삭제하려는 포스트를 가져올 수 있었다

```
src/app/[lang]/page.tsx
src/app/[lang]/defense/page.tsx
src/app/[lang]/more/page.tsx

src/app/[lang]/layout.tsx
src/app/[lang]/page.tsx
```

포켓몬 타입 계산기 프로젝트에서는 위 내용 처럼 `[lang]` 값에 따라 `/ko`, `/en`, `/ja` 페이지로 이동할 수 있도록 동적 라우팅을 구성하였다. 이렇게 대괄호를 사용해서 작성하는게 일반적인 동적 세그먼트에 해당된다.

<hr className="invisible mt-1" />

## 2-2. `[...slug]` : Catch-all Segment

...를 사용한 cath-all 규칙은 자바스크립트의 rest parameter 문법에서 영감을 받아 설계된 문법이다. 경로의 여러 세그먼트를 배열로 캡쳐하는 역할을 한다.

```
// app/docs/[...slug]/page.tsx

// 경로: /docs/1, docs/2, docs/3..
// params: { slug: ["1", "2", "3"] }
```

`[...slug]`는 여러 개의 경로 세그먼트를 배열으로 받아오며, `[...slug]/` 위치에서 하위 경로 전체를 포함한다. 필수 세그먼트가 1개가 있어야 한다. 세그먼트가 0개일 경우 매칭되지 않아서 404 에러가 발생한다. 이 경우에 `/docs` 는 접속이 불가능하지만 `/docs/1` 은 접속이 가능해질 수 있다.

위 예시와 같이 `[...slug]`를 사용해서 여러 경로의 세그먼트를 배열으로 받아올 수 있다.

<hr className="invisible mt-1" />

### catch-all 경로에서 또 다른 경로 분기하기

`[...slug]` 와 `[[...slug]]` 처럼 …를 사용한 동적 세그먼트 내에는 추가로 동적/정적 경로 추가가 불가능하다.

하지만 `[slug]` 는 가능함. `[slug]`는 그 자체가 하나의 디렉토리로 취급이 되기 때문이다.

```
app/blog/[...slug]/page.tsx  // 만들 수 있음

app/blog/[...slug]/main/page.tsx // 에러. [...slug]가 모든 하위 경로를 포괄함
```

위 예시처럼 `[...slug]` 내부에 또 다른 경로를 추가하거나 폴더를 만들면 충돌이 발생한다. 왜냐하면 catch-all은 해당 세그먼트에서 라우팅이 종료되기 때문이다.
때문에 /blog/1/main이나 /blog/2/3같이 중첩된 경로를 `[...slug]`로는 구현하기 어렵다.

<hr className="invisible mt-1" />

## 2-3. `[[...slug]]` : Optional Catch-all Segment

`[[...slug]]`의 허용 세그먼트는 0개 이상으로 없어도 되고, 여러 개가 있어도 된다.

0개 일 때에는 경로가 비어있어도 페이지가 렌더링할 수 있다는 장점이 있다.

주로 메인 페이지를 포함해서 전체 경로를 포괄할 때 사용한다.
그래서 `/docs`, `/docs/1`, `/docs/1/2` 모두 구현을 할 수 있다.

````mdx
```text
/app/docs/[[...slug]]/page.tsx // 가능. 이것만 있어야 함.

/app/docs/[[...slug]]/main/page.tsx // 에러
```
````

catch-all 과 마찬가지로 `[...slug]]` 내부에 경로를 추가할 수 없다. `[[...slug]]`는 그 아래의 경로를 모두 포함해서 포괄하겠다는 의미인데, `[[...slug]]` 내부에 다른 디렉토리가 있으면 next.js가 어떤 경로로 매핑해야하는지 알 수 없다.

근데 `[...slug]]` 내부에 경로를 추가할 수 없는데 어떻게 blog/1/2 같은 경로를 구현할 수 있다는걸까?

```tsx
export default function BlogPage({ params }: { params: { slug?: string[] } }) {
  if (!params.slug) {
    return <div>블로그 메인 페이지입니다.</div>
  }

  if (params.slug.length === 1) {
    return <div>블로그 게시글 ID: {params.slug[0]}</div>
  }

  if (params.slug.length === 2) {
    return (
      <div>
        게시글 ID: {params.slug[0]} / 하위 항목: {params.slug[1]}
      </div>
    )
  }

  return <div>잘못된 경로입니다.</div>
}
```

`[[...slug]]`는 있을 수도 있고 없을 수도 있는 여러 경로 세그먼트를 배열 형태로 받는 동적 라우트이다.

위 예시에서 `/blog` 경로의 params.slug 값은 undefined에 해당한다. `/blog/1` 에 해당하는 params.slug 값은 `['1']` 이다. `/blog/1/2` 에 해당하는 params.slug는 `['1', '2']`에 해당한다.

그래서 `[[...slug]]`를 사용할 때에는 `/app/docs/[[...slug]]/` 경로에서 page.tsx 외에 추가적인 경로를 만들지 않는다. `/app/docs/[[...slug]]/page.tsx` 에서 `/blog`, `/blog/1`, `/blog/1/2`에 해당하는 모든 경로를 처리할 수 있다.

```tsx
// app/docs/[[...slug]]/page.tsx

export default function DocsPage({ params }: { params: { slug?: string[] } }) {
  return (
    <div>
      <h1>Docs</h1>
      <p>Path: {params.slug ? params.slug.join(' / ') : '홈 (루트)'}</p>
    </div>
  )
}
```

`/docs` 와 `/docs/...` 를 모두 하나의 라우트로 처리하고 싶을 때에 유용하다. 홈이나 기본 경로에서 특정 조건에 따라 다른 화면을 보여주고자 할 때에도 유용하다.

<hr className="invisible mt-1" />

# 6. `[slug], [...slug]`, `[[...slug]]`의 차이점

````mdx
```text
// app/blog/[slug]/page.tsx
/blog              ❌
/blog/a            ✅
/blog/a/b          ❌

---

// app/blog/[...slug]/page.tsx
/blog              ❌
/blog/a            ✅ ["a"]
/blog/a/b          ✅ ["a", "b"]

---

// app/blog/[[...slug]]/page.tsx
/blog              ✅ undefined or []
/blog/a            ✅ ["a"]
/blog/a/b          ✅ ["a", "b"]
```
````

`[slug]` 내부에서 추가로 동적/정적 라우트 생성 가능

`[...slug]`, `[[...slug]]` 내부에서는 추가로 동적/정적 라우트 생성 불가능

```tsx
/app/docs/page.tsx                   → /docs
/app/docs/[category]/page.tsx       → /docs/introduction
/app/docs/[category]/main/page.tsx  → /docs/introduction/main
/app/docs/[[...slug]]/page.tsx      → /docs/introduction/main/extra
```

동적 세그먼트 사용 시 참고하기
