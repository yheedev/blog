---
title: '<실전 웹 성능 최적화 part.1> 섹션 1~2 정리'
date: '2026. 1. 3.'
tags: ['JavaScript', 'React']
topics: ['lecture', 'web-optimization']
draft: false
summary: '이미지, 텍스트, bottleneck 코드 최적화, bundle analyzer 활용, code splitting & lazy loading'
toc: true
---

[프론트엔드 개발자를 위한, 실전 웹 성능 최적화(feat. React) - Part. 1](https://www.inflearn.com/course/%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%A6%AC%EC%95%A1%ED%8A%B8-1/dashboard)

이 강의를 수강한건 2025년 8월인데, 블로그를 새로 이전하는 지금 작성한다! 유익한 내용이라 현재 진행 중인 perkwatch 프로젝트에 적용해보고 싶어서 내가 필요할 때 볼 수 있도록 정리하고 싶었다.

이 강의의 아쉬운 점은 2020년에 나온 강의라서 지금 기준으로는 다소 오래된 내용이 포함되어 있다는 점이다. 라이트하우스가 아직 Audit일 때 강의이다보니 따라가기 어려운 부분이 있었으나 본질적인 내용이 바뀐건 아니었기 때문에 따라가기 그렇게 어렵진 않았다.
3개의 섹션으로 이뤄져있는데, 첫번쨰 섹션은 성능 최적화를 왜, 무엇을, 어떻게 해야하는지 그리고 웹 성능 최적화의 주요 포인트를 설명한다.

<hr className="invisible mt-1" />

# 섹션 1: 성능 최적화 하는 이유, 주요 포인트

## 성능 최적화를 왜 해야하는가

- 페이지가 느리면 사용자가 떠난다. 반대로 페이지가 빠르게 뜨면 사용자가 머무는 시간이 길어지고, 이는 수익으로 이어진다. 구글에서 항상 웹 성능을 강조하고 집착하는 이유이다.
- 성능 최적화 기술은 프론트엔드 개발자로서 큰 경쟁력을 갖게 한다. 퍼블리싱을 떠나서 브라우저를 이해하고 웹 성능을 최적화할 수 있다는 점이 중요하다.

## 웹 성능 최적화의 주요 포인트

> 웹 성능 최적화 = 로딩 성능 최적화, 렌더링 성능 최적화

로딩 성능은 각 리소스를 불러오는 성능이고, 렌더링 성능은 각 리소스들을 화면에 보여주는 성능을 뜻한다.
어떻게 하면 더 빠르게 리소스를 로드할지, 어떻게 하면 더 빠르게 렌더링할 것인지가 무척 중요하다.
이를 위해 브라우저와 서버가 어떻게 통신하는지, 그리고 브라우저는 화면을 어떻게 그리는지 아는 것이 중요하다.

<hr className="invisible mt-1" />

# 섹션 2: 블로그 사이트 최적화

## 8강: 라이트하우스 성능 측정 도구 활용법

- opportunities: 리소스의 관점, 로딩 성능 최적화와 연관된 항목을 제시한다
- diagnostics: 페이지의 실행 관점, 렌더링 성능 최적화와 연관이 있다

## 9강: properly Sized Images

> Properly size images Est savings of 3,290 KiB
> Serve images that are appropriately-sized to save cellular data and improve load time.

위 내용을 번역하자면 '이미지를 적절한 사이즈로 압축해서 네 셀룰러 데이터와 로딩 시간을 최적화 해봐' 같은 뜻이다.

강의 중 이미지들의 렌더링된 실제 사이즈는 120x120이다. 근데 intrinsic 사이즈는 1200x1200인 상황. 실제 필요한 사이즈보다 10배나 크다는 점에서 불필요하게 큰 이미지를 사용 중이다.

### 적절한 이미지 사이즈는 어떻게 정할까?

2020년 당시 기준 많이 사용된 레티나 디스플레이는 같은 공간에 더 많은 픽셀을 그릴 수 있다. 그래서 너비 기준 2배 정도 큰 이미지를 사용하는게 적절하다
-> 120x120 이미지를 렌더링 할 경우, 240x240이 적절하다.

### 이 이미지를 어떻게 줄이지?

이 이미지는 서버 api를 통해 전달된다. 새로고침하고 네트워크 탭을 확인해보면 articles의 response를 확인해보면 이미지 링크와 포스트 정보들이 전달되는 것을 확인할 수 있다. 이미지가 자체 서버에 저장된 정적 리소스였다면 사이즈를 줄여서 올릴텐데 api를 통해서 받아오는 경우에는 클라우드나 imgix 같은 cdn을 사용하자.

- cdn (contents delivery network): 물리적 거리 한계 극복을 위해 사용자와 가까운 곳에 컨텐츠 서버를 두는 기술.

이미지 프로세싱 cdn은 기본적인 cdn 개념과 이미지를 사용자에게 보내기 전에 특정 형태로 가공 (사이즈 변경, 이미지 포맷 변경) 과정을 거쳐서 사용자에게 전달한다

그래서 `http://cdn.image.com?src=[img src]&width=200&height=100` 같은 형태로 파라미터를 통해 전달하면 이대로 가공해서 이미지를 전달해준다.

```
<img src="//img1.daumcdn.net/thumb/C120x120.fjpg/?fname=http://t1.daumcdn.net/brunch/service/user/hAN0/image/aMxlXJm_Jvoif6CmyfrHhK6jYgY.jpg" width="120" height="120" class="img_thumb" alt="">
```

cdn 도메인 + fname 필드로 이미지 주소이다. `http://t1.daumcdn.net/brunch/service/user/hAN0/image/aMxlXJm_Jvoif6CmyfrHhK6jYgY.jpg` 주소에 접속하면 원본의 커다란 이미지가 나오는데, 이것이 이미지 cdn을 거쳐서 사용자에게 작은 사이즈로 제공된다. 개인은 cdn을 직접 구축하지 않더라도 이미직스 같은 서비스를 이용해서 이미지 cdn을 사용할 수 있다

```js
// src/components/Article/index.js

<div className={'Article__thumbnail'}>
  <img
    src={
      props.image +
      getParametersForUnsplash({ width: 1200, height: 1200, quality: 80, format: 'jpg' })
    }
    alt="thumbnail"
  />
</div>
```

프로젝트의 코드를 살펴보면 이미지 주소 뿐 아니라 `getParametersForUnsplash` 함수를 넘겨주고, width, height를 파라미터로 넘겨준다는 것을 알 수 있다.
이 숫자 값을 수정하면 이미지 사이즈도 줄어들 것이다. 실제로 intrinsic 사이즈가 240x240으로 줄어들었다.

이후 다시 라이트하우스 측정하면 properly Sized Images 항목이 사라지고, 점수가 살짝 오른 것을 확인할 수 있다.

```js
// src/components/Article/index.js

/* 파라미터 참고: https://unsplash.com/documentation#supported-parameters */
function getParametersForUnsplash({ width, height, quality, format }) {
  return `?w=${width}&h=${height}&q=${quality}&fm=${format}&fit=crop`
}
```

함수 정의를 살펴보면 리터럴 템플릿으로 문자열을 생성해준다. 이것들은 unsplash에서 제공하는 이미지를 프로세싱하는 파라미터들이다. unsplash가 이미지 cdn 역할을 한다.

<hr className="invisible mt-1" />

# 10강: bottleneck 코드 탐색

> Minify JavaScript Est savings of 372 KiB
> Minifying JavaScript files can reduce payload sizes and script parse time. [Learn how to minify JavaScript](https://developer.chrome.com/docs/lighthouse/performance/unminified-javascript/?utm_source=lighthouse&utm_medium=devtools).FCPLCP

공백, 주석 등을 제거해서 자바스크립트 파일을 줄여보자~ 같은 뜻이다.

> Minimize main-thread work 2.9 s
> Consider reducing the time spent parsing, compiling and executing JS. You may find delivering smaller JS payloads helps with this

메인 스레드 작업 줄여라~ 같은 뜻이다.

> Reduce JavaScript execution time 2.0 s
> Consider reducing the time spent parsing, compiling, and executing JS. You may find delivering smaller JS payloads helps with this.

자바스크립트 파일이 실행되면서 얼만큼의 시간이 소요됐는지 알려준다.

- 개발자도구 퍼포먼스 탭 사용하는 방법: 새로고침 -> 레코드 버튼 클릭 -> 새로고침 -> 레코드 중지 -> 분석

네트워크에서 로컬호스트 요청 후, 메인 스레드에서 Parse html이 진행된다. 이후 네트워크에서 bundle.js 로딩 실행 후, 메인 스레드에서 자바스크립트 코드들 처리가 댐. src/index.js , src/App.js 등 다양하게 표시된다.

이 과정에서 removeSpecialCharactrer 함수가 Article의 시간을 잡아 먹고 있던 것을 알 수 있었다. 너무 많은 작업을 하다보니 중간중간에 가비지 컬렉터에 의해 끊기는 현상도 발생했다. 이를 개선해보자.

<hr className="invisible mt-1" />

# 11강: bottoleneck 코드 최적화

removeSpecialCharactrer 함수를 최적화 해보자. 기존의 함수는 아래와 같다.

```js
// src/components/Article/index.js

/*
 * 파라미터로 넘어온 문자열에서 일부 특수문자를 제거하는 함수
 * (Markdown으로 된 문자열의 특수문자를 제거하기 위함)
 * */
function removeSpecialCharacter(str) {
  const removeCharacters = ["#", "_", "*", "~", "&", ";", "!", "[", "]", "`", ">", "\n", "=", "-"];
  let _str = str;
  let i = 0,
    j = 0;

  for (i = 0; i < removeCharacters.length; i++) {
    j = 0;
    while (j < _str.length) {
      if (_str[j] === removeCharacters[i]) {
        _str = _str.substring(0, j).concat(_str.substring(j + 1));
        continue;
      }
      j++;
    }
  }

  return _str;
}

function Article(props) {
  const createdTime = new Date(props.createdTime);
  return (
    <div className={"Article"}>
      <div className={"Article__summary"}>
        <div className={"Article__summary__title"}>{props.title}</div>
        <div className={"Article__summary__desc"}>{removeSpecialCharacter(props.content)}</div>
```

넘겨받은 문자열에서 substring, concat 함수를 사용해서 ``["#", "_", "*", "~", "&", ";", "!", "[", "]", "`", ">", "\n", "=", "-"];``에 해당하는 특수문자를 제거한다. 즉, 특수문자 하나 제거하는데 for문을 두 번 도는 것이다.

자바스크립트는 원하는 문자열을 제거하는 replace 함수가 존재하는데, 이를 사용하지 않고 직접 구현한 점에서 성능 병목이 발생한 것으로 보인다. 또한 인자로 받아오는 마크다운 문자열이 굉장히 길텐데, 그걸 많은 반복으로 처리하니 느릴 수 밖에 없었다.

### bottleneck 해결방안

1. 특수문자를 효과적으로 제거하기
   - replace 함수, 정규식 사용
   - 마크다운의 특수문자 지워주는 라이브러리 (remove-markdown) 사용

2. 작업하는 양 줄이기
   api를 통해 제공되는 마크다운 문자열이 상당히 긴데, 이 중에서 필요한 문자열만 선별해서 사용하자

```js
let _str = str.substring(0, 300)
_str = _str.replace(/[\#\_\*\~\&\;\`\>`\n`=`-`[`]`/g, '')

return _str
```

정규식 사용해서 리팩토링하자 300줄만 가져와서 사용함,,

```
WARNING in [eslint]
src\components\Article\index.js
  Line 37:25:  Unnecessary escape character: \#  no-useless-escape
  Line 37:27:  Unnecessary escape character: \_  no-useless-escape
  Line 37:29:  Unnecessary escape character: \*  no-useless-escape
  Line 37:31:  Unnecessary escape character: \~  no-useless-escape
  Line 37:33:  Unnecessary escape character: \&  no-useless-escape
  Line 37:35:  Unnecessary escape character: \;  no-useless-escape
  Line 37:37:  Unnecessary escape character: \`  no-useless-escape
  Line 37:39:  Unnecessary escape character: \>  no-useless-escape

webpack compiled with 1 warning
```

퍼포먼스 탭을 다시 확인해보면 removeSpecialCharacter 함수에 0.14초가 걸린다고 바뀌어있다. 체감될 정도로 속도가 빨라졌고 라이트하우스 점수도 많이 개선되었다.

<hr className="invisible mt-1" />

# 12강: bundle analyzer

번들 js 파일 용량이 엄청 크다. 어떻게 최적화하고 로딩 단축시킬 수 있을까?

구글 webpack bundle analyzer 검색후 사용해보자. 적용하려면 webpack.config을 수정해야하는데, CRA는 직접 웹팩을 수정하기에 번거롭다. CRA는 아래 명령어를 실행해서 설치하면 된다.

```
npm install --save-dev cra-bundle-analyzer
```

그리고 사용할 때 이 명령어 실행한다.

```
npx cra-bundle-analyzer
```

package-lock.json을 보면 사용 중인 모듈의 하위 dependency를 표시해준다. 특정 모듈을 사용할 때는 어떤 모듈들을 같이 설치해서 사용하는게 좋은지 명시한다.

```js
    "react-syntax-highlighter": {
      "version": "15.6.1",
      "resolved": "https://registry.npmjs.org/react-syntax-highlighter/-/react-syntax-highlighter-15.6.1.tgz",
      "integrity": "sha512-OqJ2/vL7lEeV5zTJyG7kmARppUjiB9h9udl4qHQjjgEos66z00Ia0OckwYfRxCSFrW8RJIBnsBwQsHZbVPspqg==",
      "requires": {
        "@babel/runtime": "^7.3.1",
        "highlight.js": "^10.4.1",
        "highlightjs-vue": "^1.0.0",
        "lowlight": "^1.17.0",
        "prismjs": "^1.27.0",
        "refractor": "^3.6.0"
      }
    },
```

"react-syntax-highlighter" 모듈을 사용하려면 refractor 모듈을 3.6.0 버전을 사용해야한다. react-syntax-highlighter는 코드블럭을 강조해주는 모듈인데, 특정 게시글의 코드블럭에서만 사용된다.

그러니까 리스트에 해당하는 메인 페이지에서는 코드 블럭 모듈을 가져올 필요가 없고, 뷰 페이지에서만 가져오면 된다는 것이다. 코드를 필요한만큼 분리시키고 필요할 때만 로딩해보자.

<hr className="invisible mt-1" />

# 13강: code splitting & lazy loading

코드 분할이란 덩치 큰 번들 파일을 쪼개서 작은 사이즈의 파일으로 만든다는 뜻이다.

현재 bundle.js라는 하나의 파일에 두 개의 page 컴포넌트가 들어가있다. 하나의 파일 내에 리스트 페이지에 접속하면, 당장 필요하지 않은 뷰 페이지의 모듈들까지 모두 로드를 한다는 뜻이다. 이 상태에서 필요한 코드들만 다운로드 받으면 로딩 속도가 빨라질 것이다.

<div>
![](/static/images/lecture/code-splitting1.png)

![](/static/images/lecture/code-splitting2.png)

</div>

위 예시 이미지같은 페이지 별 분할 패턴도 있고, 페이지끼리 공통적으로 사용하는 모듈이 많다면 모듈별로 코드를 분할해서 사용하는 패턴도 있다.
이 두 가지 방식을 혼용할 수 있다.

중요한건 불필요한 코드, 중복되는 코드 없이 적절한 사이즈의 코드가 적절한 타이밍에 로드될 수 있도록 하는 것이다.
